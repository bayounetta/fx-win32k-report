# HG changeset patch
# User Bob Owen <bobowencode@gmail.com>
# Date 1543760036 0
#      Sun Dec 02 14:13:56 2018 +0000
# Node ID 8a2c7fed93f0393103feaa8f8a2b23286072ba6e
# Parent  345e10501cf7af901c2c6fa7198d698c1158e995
Bug 1464032 Rolled up - parts 2 to 15.

Bug 1464032 Part 2: Remove LoadEvent and replace with DoWithEvent.

This patch modifies DoWithEvent so that we can more easily have a
DoWithEventFromStream callable from outside of Moz2D similar to
LoadEventFromStream. We will add that in a later patch for the new
EventRingBuffer. It also changes the only user of LoadEventFromStream
over to it, so we can can get rid of it and LoadEvent entirely.
* * *
Bug 1464032 Part 3: Remove unused GetObjectRef.
* * *
Bug 1464032 Part 4: Record DrawTarget::Flush and DrawTarget::DetachAllSnapshots.
* * *
Bug 1464032 Part 5: Make sure the DrawTarget can create a similar DrawTarget when falling back to empty surface.

Otherwise, we crash in the content process when we try to record this.
* * *
Bug 1464032 Part 6: Add remote canvas pref and refactor TextuteData creation to use it.

This is ground work for when we will be returning a recording TextureData for
certain types in subsequent patches.
* * *
Bug 1464032 Part 7: Take snapshot before return for TextureClients with synchronization.

This is so we don't need to lock the previous back buffer when it might also be
locked by the compositor. These locks are generally for copying to the next
back buffer or when getting image data from the previous back buffer.
This also makes it easier to asynchronously cache the DataSourceSurface in the
GPU process, when a page is using getImageData. This is done in a later patch.
* * *
Bug 1464032 Part 8: Add a CanvasEventRingBuffer and CanvasDrawEventRecorder.

These are to be used as part of recording canvas drawing in the content
processes and playing it back in the GPU process through shared memory.
* * *
Bug 1464032 Part 9: Add a D3D11 device to be used on canvas threads in the GPU process.
* * *
Bug 1464032 Part 10: Add a CanvasTranslator and canvas recorded events.

These are extensions to the Moz2D RecordedEvents to record and play back canvas
texture related functions in the GPU process.
The CanvasTranslator handles the playback of these and the Moz2D ones.
* * *
Bug 1464032 Part 11: Add DataSurfaceProvider to be used to retrieve surface data from a SourceSurfaceRecording.
* * *
Bug 1464032 Part 12: Add CanvasParent, CanvasChild and RecordedTextureData.

RecordedTextureData records TextureData calls for play back in the GPU process.
CanvasChild and CanvasParent set up the recorder and translator.
They also help to manage the starting of translation and co-ordinating the
translation with the frame transactions.
This patch also includes other changes to wire up recording and playback.
* * *
Bug 1464032 Part 13: Make the recording of surface data more efficient.
* * *
Bug 1464032 Part 14: Refactor Path recording to record Arc properly.

This also improves the recording and translation speeds.
* * *
Bug 1464032 Part 15: Spread the playback of canvas recordings across multiple threads in the GPU process.

diff --git a/gfx/2d/2D.h b/gfx/2d/2D.h
--- a/gfx/2d/2D.h
+++ b/gfx/2d/2D.h
@@ -56,16 +56,17 @@ struct FT_FaceRec_;
 typedef FT_FaceRec_ *FT_Face;
 
 typedef int FT_Error;
 
 struct ID3D11Texture2D;
 struct ID3D11Device;
 struct ID2D1Device;
 struct ID2D1DeviceContext;
+struct ID2D1Multithread;
 struct IDWriteFactory;
 struct IDWriteRenderingParams;
 struct IDWriteFontFace;
 struct IDWriteFontCollection;
 
 class GrContext;
 class SkCanvas;
 struct gfxFontStyle;
@@ -1855,12 +1856,23 @@ class GFX2D_API Factory {
 
   friend class DrawTargetD2D1;
 #endif
 
  private:
   static DrawEventRecorder *mRecorder;
 };
 
+class MOZ_RAII AutoMoz2DSerialize final {
+ public:
+  explicit AutoMoz2DSerialize(BackendType aBackendType);
+  ~AutoMoz2DSerialize();
+
+ private:
+#if defined(WIN32)
+  RefPtr<ID2D1Multithread> mMT;
+#endif
+};
+
 }  // namespace gfx
 }  // namespace mozilla
 
 #endif  // _MOZILLA_GFX_2D_H
diff --git a/gfx/2d/DrawTargetRecording.cpp b/gfx/2d/DrawTargetRecording.cpp
--- a/gfx/2d/DrawTargetRecording.cpp
+++ b/gfx/2d/DrawTargetRecording.cpp
@@ -53,62 +53,86 @@ static void EnsureSurfaceStoredRecording
                         &RecordingSourceSurfaceUserDataFunc);
 }
 
 class SourceSurfaceRecording : public SourceSurface {
  public:
   MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(SourceSurfaceRecording, override)
 
   SourceSurfaceRecording(IntSize aSize, SurfaceFormat aFormat,
-                         DrawEventRecorderPrivate *aRecorder)
-      : mSize(aSize), mFormat(aFormat), mRecorder(aRecorder) {
+                         DrawEventRecorderPrivate *aRecorder,
+                         DataSurfaceProvider *aDataSurfaceProvider)
+      : mSize(aSize),
+        mFormat(aFormat),
+        mRecorder(aRecorder),
+        mDataSurfaceProvider(aDataSurfaceProvider) {
     mRecorder->AddStoredObject(this);
   }
 
   ~SourceSurfaceRecording() {
     mRecorder->RemoveStoredObject(this);
     mRecorder->RecordEvent(
         RecordedSourceSurfaceDestruction(ReferencePtr(this)));
   }
 
   virtual SurfaceType GetType() const override {
     return SurfaceType::RECORDING;
   }
   virtual IntSize GetSize() const override { return mSize; }
   virtual SurfaceFormat GetFormat() const override { return mFormat; }
   virtual already_AddRefed<DataSourceSurface> GetDataSurface() override {
-    return nullptr;
+    if (!mDataSurfaceProvider) {
+      return nullptr;
+    }
+
+    if (!mDataSourceSurface) {
+      mDataSourceSurface = mDataSurfaceProvider->GetDataSurface(this);
+    }
+
+    return do_AddRef(mDataSourceSurface);
   }
 
   IntSize mSize;
   SurfaceFormat mFormat;
   RefPtr<DrawEventRecorderPrivate> mRecorder;
+  DataSurfaceProvider *mDataSurfaceProvider;
+  RefPtr<DataSourceSurface> mDataSourceSurface;
 };
 
 class DataSourceSurfaceRecording : public DataSourceSurface {
  public:
   MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(DataSourceSurfaceRecording, override)
   DataSourceSurfaceRecording(UniquePtr<uint8_t[]> aData, IntSize aSize,
-                             int32_t aStride, SurfaceFormat aFormat)
+                             int32_t aStride, SurfaceFormat aFormat,
+                             DrawEventRecorderPrivate *aRecorder)
       : mData(std::move(aData)),
         mSize(aSize),
         mStride(aStride),
-        mFormat(aFormat) {}
-
-  ~DataSourceSurfaceRecording() {}
+        mFormat(aFormat),
+        mRecorder(aRecorder) {
+    mRecorder->RecordEvent(RecordedSourceSurfaceCreation(
+        ReferencePtr(this), mData.get(), mStride, mSize, mFormat));
+    mRecorder->AddStoredObject(this);
+  }
 
-  static already_AddRefed<DataSourceSurface> Init(uint8_t *aData, IntSize aSize,
-                                                  int32_t aStride,
-                                                  SurfaceFormat aFormat) {
+  ~DataSourceSurfaceRecording() {
+    mRecorder->RemoveStoredObject(this);
+    mRecorder->RecordEvent(
+        RecordedSourceSurfaceDestruction(ReferencePtr(this)));
+  }
+
+  static already_AddRefed<DataSourceSurface> Init(
+      uint8_t *aData, IntSize aSize, int32_t aStride, SurfaceFormat aFormat,
+      DrawEventRecorderPrivate *aRecorder) {
     // XXX: do we need to ensure any alignment here?
     auto data = MakeUnique<uint8_t[]>(aStride * aSize.height);
     if (data) {
       memcpy(data.get(), aData, aStride * aSize.height);
       RefPtr<DataSourceSurfaceRecording> surf = new DataSourceSurfaceRecording(
-          std::move(data), aSize, aStride, aFormat);
+          std::move(data), aSize, aStride, aFormat, aRecorder);
       return surf.forget();
     }
     return nullptr;
   }
 
   virtual SurfaceType GetType() const override {
     return SurfaceType::RECORDING;
   }
@@ -116,16 +140,17 @@ class DataSourceSurfaceRecording : publi
   virtual int32_t Stride() override { return mStride; }
   virtual SurfaceFormat GetFormat() const override { return mFormat; }
   virtual uint8_t *GetData() override { return mData.get(); }
 
   UniquePtr<uint8_t[]> mData;
   IntSize mSize;
   int32_t mStride;
   SurfaceFormat mFormat;
+  RefPtr<DrawEventRecorderPrivate> mRecorder;
 };
 
 class GradientStopsRecording : public GradientStops {
  public:
   MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(GradientStopsRecording, override)
 
   explicit GradientStopsRecording(DrawEventRecorderPrivate *aRecorder)
       : mRecorder(aRecorder) {
@@ -202,32 +227,36 @@ class FilterNodeRecording : public Filte
 
   virtual FilterBackend GetBackendType() override {
     return FILTER_BACKEND_RECORDING;
   }
 
   RefPtr<DrawEventRecorderPrivate> mRecorder;
 };
 
-DrawTargetRecording::DrawTargetRecording(DrawEventRecorder *aRecorder,
-                                         DrawTarget *aDT, IntSize aSize,
-                                         bool aHasData)
+DrawTargetRecording::DrawTargetRecording(
+    DrawEventRecorder *aRecorder, DrawTarget *aDT, IntSize aSize, bool aHasData,
+    DataSurfaceProvider *aDataSurfaceProvider)
     : mRecorder(static_cast<DrawEventRecorderPrivate *>(aRecorder)),
       mFinalDT(aDT),
-      mSize(aSize) {
+      mSize(aSize),
+      mDataSurfaceProvider(aDataSurfaceProvider) {
   RefPtr<SourceSurface> snapshot = aHasData ? mFinalDT->Snapshot() : nullptr;
   mRecorder->RecordEvent(
       RecordedDrawTargetCreation(this, mFinalDT->GetBackendType(), mSize,
                                  mFinalDT->GetFormat(), aHasData, snapshot));
   mFormat = mFinalDT->GetFormat();
 }
 
 DrawTargetRecording::DrawTargetRecording(const DrawTargetRecording *aDT,
                                          IntSize aSize, SurfaceFormat aFormat)
-    : mRecorder(aDT->mRecorder), mFinalDT(aDT->mFinalDT), mSize(aSize) {
+    : mRecorder(aDT->mRecorder),
+      mFinalDT(aDT->mFinalDT),
+      mSize(aSize),
+      mDataSurfaceProvider(aDT->mDataSurfaceProvider) {
   mFormat = aFormat;
 }
 
 DrawTargetRecording::~DrawTargetRecording() {
   mRecorder->RecordEvent(RecordedDrawTargetDestruction(ReferencePtr(this)));
 }
 
 void DrawTargetRecording::FillRect(const Rect &aRect, const Pattern &aPattern,
@@ -352,36 +381,42 @@ void DrawTargetRecording::Stroke(const P
   RefPtr<PathRecording> pathRecording = EnsurePathStored(aPath);
   EnsurePatternDependenciesStored(aPattern);
 
   mRecorder->RecordEvent(
       RecordedStroke(this, pathRecording, aPattern, aStrokeOptions, aOptions));
 }
 
 already_AddRefed<SourceSurface> DrawTargetRecording::Snapshot() {
-  RefPtr<SourceSurface> retSurf =
-      new SourceSurfaceRecording(mSize, mFormat, mRecorder);
+  RefPtr<SourceSurface> retSurf = new SourceSurfaceRecording(
+      mSize, mFormat, mRecorder, mDataSurfaceProvider);
 
   mRecorder->RecordEvent(RecordedSnapshot(retSurf, this));
 
   return retSurf.forget();
 }
 
 already_AddRefed<SourceSurface> DrawTargetRecording::IntoLuminanceSource(
     LuminanceType aLuminanceType, float aOpacity) {
-  RefPtr<SourceSurface> retSurf =
-      new SourceSurfaceRecording(mSize, SurfaceFormat::A8, mRecorder);
+  RefPtr<SourceSurface> retSurf = new SourceSurfaceRecording(
+      mSize, SurfaceFormat::A8, mRecorder, mDataSurfaceProvider);
 
   mRecorder->RecordEvent(
       RecordedIntoLuminanceSource(retSurf, this, aLuminanceType, aOpacity));
 
   return retSurf.forget();
 }
 
-void DrawTargetRecording::DetachAllSnapshots() {}
+void DrawTargetRecording::Flush() {
+  mRecorder->RecordEvent(RecordedFlush(this));
+}
+
+void DrawTargetRecording::DetachAllSnapshots() {
+  mRecorder->RecordEvent(RecordedDetachAllSnapshots(this));
+}
 
 void DrawTargetRecording::DrawSurface(SourceSurface *aSurface,
                                       const Rect &aDest, const Rect &aSource,
                                       const DrawSurfaceOptions &aSurfOptions,
                                       const DrawOptions &aOptions) {
   EnsureSurfaceStoredRecording(mRecorder, aSurface, "DrawSurface");
 
   mRecorder->RecordEvent(RecordedDrawSurface(this, aSurface, aDest, aSource,
@@ -483,26 +518,19 @@ void DrawTargetRecording::PopLayer() {
   mRecorder->RecordEvent(RecordedPopLayer(static_cast<DrawTarget *>(this)));
 }
 
 already_AddRefed<SourceSurface>
 DrawTargetRecording::CreateSourceSurfaceFromData(unsigned char *aData,
                                                  const IntSize &aSize,
                                                  int32_t aStride,
                                                  SurfaceFormat aFormat) const {
-  RefPtr<SourceSurface> surf =
-      DataSourceSurfaceRecording::Init(aData, aSize, aStride, aFormat);
-
-  RefPtr<SourceSurface> retSurf =
-      new SourceSurfaceRecording(aSize, aFormat, mRecorder);
-
-  mRecorder->RecordEvent(
-      RecordedSourceSurfaceCreation(retSurf, aData, aStride, aSize, aFormat));
-
-  return retSurf.forget();
+  RefPtr<SourceSurface> surf = DataSourceSurfaceRecording::Init(
+      aData, aSize, aStride, aFormat, mRecorder);
+  return surf.forget();
 }
 
 already_AddRefed<SourceSurface> DrawTargetRecording::OptimizeSourceSurface(
     SourceSurface *aSurface) const {
   RefPtr<SourceSurface> surf(aSurface);
   return surf.forget();
 }
 
diff --git a/gfx/2d/DrawTargetRecording.h b/gfx/2d/DrawTargetRecording.h
--- a/gfx/2d/DrawTargetRecording.h
+++ b/gfx/2d/DrawTargetRecording.h
@@ -12,17 +12,18 @@
 
 namespace mozilla {
 namespace gfx {
 
 class DrawTargetRecording : public DrawTarget {
  public:
   MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(DrawTargetRecording, override)
   DrawTargetRecording(DrawEventRecorder *aRecorder, DrawTarget *aDT,
-                      IntSize aSize, bool aHasData = false);
+                      IntSize aSize, bool aHasData = false,
+                      DataSurfaceProvider *aDataSurfaceProvider = nullptr);
 
   ~DrawTargetRecording();
 
   virtual DrawTargetType GetType() const override {
     return mFinalDT->GetType();
   }
   virtual BackendType GetBackendType() const override {
     return BackendType::RECORDING;
@@ -32,21 +33,17 @@ class DrawTargetRecording : public DrawT
   virtual already_AddRefed<SourceSurface> Snapshot() override;
   virtual already_AddRefed<SourceSurface> IntoLuminanceSource(
       LuminanceType aLuminanceType, float aOpacity) override;
 
   virtual void DetachAllSnapshots() override;
 
   virtual IntSize GetSize() const override { return mSize; }
 
-  /* Ensure that the DrawTarget backend has flushed all drawing operations to
-   * this draw target. This must be called before using the backing surface of
-   * this draw target outside of GFX 2D code.
-   */
-  virtual void Flush() override { mFinalDT->Flush(); }
+  virtual void Flush() override;
 
   virtual void FlushItem(const IntRect &aBounds) override;
 
   /*
    * Draw a surface to the draw target. Possibly doing partial drawing or
    * applying scaling. No sampling happens outside the source.
    *
    * aSurface Source surface to draw
@@ -364,14 +361,15 @@ class DrawTargetRecording : public DrawT
 
   Path *GetPathForPathRecording(const Path *aPath) const;
   already_AddRefed<PathRecording> EnsurePathStored(const Path *aPath);
   void EnsurePatternDependenciesStored(const Pattern &aPattern);
 
   RefPtr<DrawEventRecorderPrivate> mRecorder;
   RefPtr<DrawTarget> mFinalDT;
   IntSize mSize;
+  DataSurfaceProvider *mDataSurfaceProvider;
 };
 
 }  // namespace gfx
 }  // namespace mozilla
 
 #endif /* MOZILLA_GFX_DRAWTARGETRECORDING_H_ */
diff --git a/gfx/2d/Factory.cpp b/gfx/2d/Factory.cpp
--- a/gfx/2d/Factory.cpp
+++ b/gfx/2d/Factory.cpp
@@ -716,16 +716,40 @@ void Factory::ReleaseFTFace(FT_Face aFac
 
 FT_Error Factory::LoadFTGlyph(FT_Face aFace, uint32_t aGlyphIndex,
                               int32_t aFlags) {
   StaticMutexAutoLock lock(mFTLock);
   return FT_Load_Glyph(aFace, aGlyphIndex, aFlags);
 }
 #endif
 
+AutoMoz2DSerialize::AutoMoz2DSerialize(BackendType aBackendType) {
+#ifdef WIN32
+  // We use a multi-threaded ID2D1Factory1, so that makes the calls through the
+  // Direct2D API thread-safe. However, if the Moz2D objects are using Direct3D
+  // resources we need to make sure that calls through the Direct3D or DXGI API
+  // use the Direct2D synchronization. It's possible that this should be pushed
+  // down into the TextureD3D11 objects, so that we always use this.
+  if (aBackendType == BackendType::DIRECT2D1_1 ||
+      aBackendType == BackendType::DIRECT2D) {
+    D2DFactory()->QueryInterface(
+        static_cast<ID2D1Multithread**>(getter_AddRefs(mMT)));
+    mMT->Enter();
+  }
+#endif
+}
+
+AutoMoz2DSerialize::~AutoMoz2DSerialize() {
+#ifdef WIN32
+  if (mMT) {
+    mMT->Leave();
+  }
+#endif
+};
+
 #ifdef WIN32
 already_AddRefed<DrawTarget> Factory::CreateDrawTargetForD3D11Texture(
     ID3D11Texture2D* aTexture, SurfaceFormat aFormat) {
   MOZ_ASSERT(aTexture);
 
   RefPtr<DrawTargetD2D1> newTarget;
 
   newTarget = new DrawTargetD2D1();
diff --git a/gfx/2d/InlineTranslator.cpp b/gfx/2d/InlineTranslator.cpp
--- a/gfx/2d/InlineTranslator.cpp
+++ b/gfx/2d/InlineTranslator.cpp
@@ -64,17 +64,17 @@ bool InlineTranslator::TranslateRecordin
     return false;
   }
 
   int32_t eventType;
   ReadElement(reader, eventType);
   while (reader.good()) {
     bool success = RecordedEvent::DoWithEvent(
         reader, static_cast<RecordedEvent::EventType>(eventType),
-        [&](RecordedEvent *recordedEvent) {
+        [&](RecordedEvent *recordedEvent) -> bool {
           // Make sure that the whole event was read from the stream
           // successfully.
           if (!reader.good()) {
             mError = " READ";
             return false;
           }
 
           if (!recordedEvent->PlayEvent(this)) {
diff --git a/gfx/2d/InlineTranslator.h b/gfx/2d/InlineTranslator.h
--- a/gfx/2d/InlineTranslator.h
+++ b/gfx/2d/InlineTranslator.h
@@ -121,23 +121,23 @@ class InlineTranslator : public Translat
     mUnscaledFonts.Put(aRefPtr, aUnscaledFont);
   }
 
   void AddNativeFontResource(uint64_t aKey,
                              NativeFontResource* aScaledFontResouce) final {
     mNativeFontResources.Put(aKey, aScaledFontResouce);
   }
 
-  void RemoveDrawTarget(ReferencePtr aRefPtr) final {
+  void RemoveDrawTarget(ReferencePtr aRefPtr) override {
     mDrawTargets.Remove(aRefPtr);
   }
 
   void RemovePath(ReferencePtr aRefPtr) final { mPaths.Remove(aRefPtr); }
 
-  void RemoveSourceSurface(ReferencePtr aRefPtr) final {
+  void RemoveSourceSurface(ReferencePtr aRefPtr) override {
     mSourceSurfaces.Remove(aRefPtr);
   }
 
   void RemoveFilterNode(ReferencePtr aRefPtr) final {
     mFilterNodes.Remove(aRefPtr);
   }
 
   void RemoveGradientStops(ReferencePtr aRefPtr) final {
@@ -149,17 +149,17 @@ class InlineTranslator : public Translat
   }
 
   void RemoveUnscaledFont(ReferencePtr aRefPtr) final {
     mUnscaledFonts.Remove(aRefPtr);
   }
 
   already_AddRefed<DrawTarget> CreateDrawTarget(
       ReferencePtr aRefPtr, const gfx::IntSize& aSize,
-      gfx::SurfaceFormat aFormat) final;
+      gfx::SurfaceFormat aFormat) override;
 
   mozilla::gfx::DrawTarget* GetReferenceDrawTarget() final { return mBaseDT; }
 
   void* GetFontContext() final { return mFontContext; }
   std::string GetError() { return mError; }
 
  private:
   RefPtr<DrawTarget> mBaseDT;
diff --git a/gfx/2d/Logging.h b/gfx/2d/Logging.h
--- a/gfx/2d/Logging.h
+++ b/gfx/2d/Logging.h
@@ -129,17 +129,18 @@ enum class LogReason : int {
   InvalidCacheSurface,
   AlphaWithBasicClient,
   UnbalancedClipStack,
   ProcessingError,
   InvalidDrawTarget,
   NativeFontResourceNotFound,
   UnscaledFontNotFound,
   ScaledFontNotFound,
-  InvalidLayerType,
+  InvalidLayerType,  // 40
+  PlayEventFailed,
   // End
   MustBeLessThanThis = 101,
 };
 
 struct BasicLogger {
   // For efficiency, this method exists and copies the logic of the
   // OutputMessage below.  If making any changes here, also make it
   // in the appropriate places in that method.
diff --git a/gfx/2d/PathHelpers.h b/gfx/2d/PathHelpers.h
--- a/gfx/2d/PathHelpers.h
+++ b/gfx/2d/PathHelpers.h
@@ -118,17 +118,17 @@ inline void AcuteArcToBezier(T* aSink, c
                              Float aEndAngle) {
   AcuteArcToBezier(aSink, aOrigin, aRadius, aStartPoint, aEndPoint,
                    ComputeKappaFactor(aEndAngle - aStartAngle));
 }
 
 template <typename T>
 void ArcToBezier(T* aSink, const Point& aOrigin, const Size& aRadius,
                  float aStartAngle, float aEndAngle, bool aAntiClockwise,
-                 float aRotation = 0.0f) {
+                 float aRotation = 0.0f, const Matrix& aTransform = Matrix()) {
   Float sweepDirection = aAntiClockwise ? -1.0f : 1.0f;
 
   // Calculate the total arc we're going to sweep.
   Float arcSweepLeft = (aEndAngle - aStartAngle) * sweepDirection;
 
   // Clockwise we always sweep from the smaller to the larger angle, ccw
   // it's vice versa.
   if (arcSweepLeft < 0) {
@@ -143,16 +143,17 @@ void ArcToBezier(T* aSink, const Point& 
 
   Float currentStartAngle = aStartAngle;
   Point currentStartOffset(cosf(aStartAngle), sinf(aStartAngle));
   Matrix transform = Matrix::Scaling(aRadius.width, aRadius.height);
   if (aRotation != 0.0f) {
     transform *= Matrix::Rotation(aRotation);
   }
   transform.PostTranslate(aOrigin);
+  transform *= aTransform;
   aSink->LineTo(transform.TransformPoint(currentStartOffset));
 
   while (arcSweepLeft > 0) {
     Float currentEndAngle =
         currentStartAngle +
         std::min(arcSweepLeft, Float(M_PI / 2.0f)) * sweepDirection;
     Point currentEndOffset(cosf(currentEndAngle), sinf(currentEndAngle));
 
diff --git a/gfx/2d/PathRecording.cpp b/gfx/2d/PathRecording.cpp
--- a/gfx/2d/PathRecording.cpp
+++ b/gfx/2d/PathRecording.cpp
@@ -6,106 +6,217 @@
 
 #include "PathRecording.h"
 #include "DrawEventRecorder.h"
 #include "RecordedEventImpl.h"
 
 namespace mozilla {
 namespace gfx {
 
+#define NEXT_PARAMS(_type)                                         \
+  const _type params = *reinterpret_cast<const _type *>(nextByte); \
+  nextByte += sizeof(_type);
+
 using namespace std;
 
+bool PathOps::StreamToSink(PathSink &aPathSink) const {
+  if (mPathData.empty()) {
+    return false;
+  }
+
+  const uint8_t *nextByte = mPathData.data();
+  const uint8_t *end = nextByte + mPathData.size();
+  while (nextByte < end) {
+    const OpType opType = *reinterpret_cast<const OpType *>(nextByte);
+    nextByte += sizeof(OpType);
+    switch (opType) {
+      case OpType::OP_MOVETO: {
+        NEXT_PARAMS(Point)
+        aPathSink.MoveTo(params);
+        break;
+      }
+      case OpType::OP_LINETO: {
+        NEXT_PARAMS(Point)
+        aPathSink.LineTo(params);
+        break;
+      }
+      case OpType::OP_BEZIERTO: {
+        NEXT_PARAMS(ThreePoints)
+        aPathSink.BezierTo(params.p1, params.p2, params.p3);
+        break;
+      }
+      case OpType::OP_QUADRATICBEZIERTO: {
+        NEXT_PARAMS(TwoPoints)
+        aPathSink.QuadraticBezierTo(params.p1, params.p2);
+        break;
+      }
+      case OpType::OP_ARC: {
+        NEXT_PARAMS(ArcParams)
+        aPathSink.Arc(params.origin, params.radius, params.startAngle,
+                      params.endAngle, params.antiClockwise);
+        break;
+      }
+      case OpType::OP_CLOSE:
+        aPathSink.Close();
+        break;
+      default:
+        MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE(
+            "We control mOpTypes, so this should never happen.");
+    }
+  }
+
+  return true;
+}
+
+PathOps PathOps::TransformedCopy(const Matrix &aTransform) const {
+  PathOps newPathOps;
+  const uint8_t *nextByte = mPathData.data();
+  const uint8_t *end = nextByte + mPathData.size();
+  while (nextByte < end) {
+    const OpType opType = *reinterpret_cast<const OpType *>(nextByte);
+    nextByte += sizeof(OpType);
+    switch (opType) {
+      case OpType::OP_MOVETO: {
+        NEXT_PARAMS(Point)
+        newPathOps.MoveTo(aTransform.TransformPoint(params));
+        break;
+      }
+      case OpType::OP_LINETO: {
+        NEXT_PARAMS(Point)
+        newPathOps.LineTo(aTransform.TransformPoint(params));
+        break;
+      }
+      case OpType::OP_BEZIERTO: {
+        NEXT_PARAMS(ThreePoints)
+        newPathOps.BezierTo(aTransform.TransformPoint(params.p1),
+                            aTransform.TransformPoint(params.p2),
+                            aTransform.TransformPoint(params.p3));
+        break;
+      }
+      case OpType::OP_QUADRATICBEZIERTO: {
+        NEXT_PARAMS(TwoPoints)
+        newPathOps.QuadraticBezierTo(aTransform.TransformPoint(params.p1),
+                                     aTransform.TransformPoint(params.p2));
+        break;
+      }
+      case OpType::OP_ARC: {
+        NEXT_PARAMS(ArcParams)
+        ArcToBezier(&newPathOps, params.origin,
+                    gfx::Size(params.radius, params.radius), params.startAngle,
+                    params.endAngle, params.antiClockwise, 0.0f, aTransform);
+        break;
+      }
+      case OpType::OP_CLOSE:
+        newPathOps.Close();
+        break;
+      default:
+        MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE(
+            "We control mOpTypes, so this should never happen.");
+    }
+  }
+
+  return newPathOps;
+}
+
+size_t PathOps::Size() const {
+  size_t size = 0;
+  const uint8_t *nextByte = mPathData.data();
+  const uint8_t *end = nextByte + mPathData.size();
+  while (nextByte < end) {
+    size++;
+    const OpType opType = *reinterpret_cast<const OpType *>(nextByte);
+    nextByte += sizeof(OpType);
+    switch (opType) {
+      case OpType::OP_MOVETO:
+        nextByte += sizeof(Point);
+        break;
+      case OpType::OP_LINETO:
+        nextByte += sizeof(Point);
+        break;
+      case OpType::OP_BEZIERTO:
+        nextByte += sizeof(ThreePoints);
+        break;
+      case OpType::OP_QUADRATICBEZIERTO:
+        nextByte += sizeof(TwoPoints);
+        break;
+      case OpType::OP_ARC:
+        nextByte += sizeof(ArcParams);
+        break;
+      case OpType::OP_CLOSE:
+        break;
+      default:
+        MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE(
+            "We control mOpTypes, so this should never happen.");
+    }
+  }
+
+  return size;
+}
+
 void PathBuilderRecording::MoveTo(const Point &aPoint) {
-  PathOp op;
-  op.mType = PathOp::OP_MOVETO;
-  op.mP1 = aPoint;
-  mPathOps.push_back(op);
+  mPathOps.MoveTo(aPoint);
   mPathBuilder->MoveTo(aPoint);
 }
 
 void PathBuilderRecording::LineTo(const Point &aPoint) {
-  PathOp op;
-  op.mType = PathOp::OP_LINETO;
-  op.mP1 = aPoint;
-  mPathOps.push_back(op);
+  mPathOps.LineTo(aPoint);
   mPathBuilder->LineTo(aPoint);
 }
 
 void PathBuilderRecording::BezierTo(const Point &aCP1, const Point &aCP2,
                                     const Point &aCP3) {
-  PathOp op;
-  op.mType = PathOp::OP_BEZIERTO;
-  op.mP1 = aCP1;
-  op.mP2 = aCP2;
-  op.mP3 = aCP3;
-  mPathOps.push_back(op);
+  mPathOps.BezierTo(aCP1, aCP2, aCP3);
   mPathBuilder->BezierTo(aCP1, aCP2, aCP3);
 }
 
 void PathBuilderRecording::QuadraticBezierTo(const Point &aCP1,
                                              const Point &aCP2) {
-  PathOp op;
-  op.mType = PathOp::OP_QUADRATICBEZIERTO;
-  op.mP1 = aCP1;
-  op.mP2 = aCP2;
-  mPathOps.push_back(op);
+  mPathOps.QuadraticBezierTo(aCP1, aCP2);
   mPathBuilder->QuadraticBezierTo(aCP1, aCP2);
 }
 
 void PathBuilderRecording::Close() {
-  PathOp op;
-  op.mType = PathOp::OP_CLOSE;
-  mPathOps.push_back(op);
+  mPathOps.Close();
   mPathBuilder->Close();
 }
 
+void PathBuilderRecording::Arc(const Point &aOrigin, float aRadius,
+                               float aStartAngle, float aEndAngle,
+                               bool aAntiClockwise) {
+  mPathOps.Arc(aOrigin, aRadius, aStartAngle, aEndAngle, aAntiClockwise);
+  mPathBuilder->Arc(aOrigin, aRadius, aStartAngle, aEndAngle, aAntiClockwise);
+}
+
 Point PathBuilderRecording::CurrentPoint() const {
   return mPathBuilder->CurrentPoint();
 }
 
 already_AddRefed<Path> PathBuilderRecording::Finish() {
   RefPtr<Path> path = mPathBuilder->Finish();
-  return MakeAndAddRef<PathRecording>(path, mPathOps, mFillRule);
+  return MakeAndAddRef<PathRecording>(path, std::move(mPathOps), mFillRule);
 }
 
 PathRecording::~PathRecording() {
   for (size_t i = 0; i < mStoredRecorders.size(); i++) {
     mStoredRecorders[i]->RemoveStoredObject(this);
     mStoredRecorders[i]->RecordEvent(RecordedPathDestruction(this));
   }
 }
 
 already_AddRefed<PathBuilder> PathRecording::CopyToBuilder(
     FillRule aFillRule) const {
   RefPtr<PathBuilder> pathBuilder = mPath->CopyToBuilder(aFillRule);
   RefPtr<PathBuilderRecording> recording =
-      new PathBuilderRecording(pathBuilder, aFillRule);
-  recording->mPathOps = mPathOps;
+      new PathBuilderRecording(pathBuilder, mPathOps, aFillRule);
   return recording.forget();
 }
 
 already_AddRefed<PathBuilder> PathRecording::TransformedCopyToBuilder(
     const Matrix &aTransform, FillRule aFillRule) const {
   RefPtr<PathBuilder> pathBuilder =
       mPath->TransformedCopyToBuilder(aTransform, aFillRule);
-  RefPtr<PathBuilderRecording> recording =
-      new PathBuilderRecording(pathBuilder, aFillRule);
-  typedef std::vector<PathOp> pathOpVec;
-  for (pathOpVec::const_iterator iter = mPathOps.begin();
-       iter != mPathOps.end(); iter++) {
-    PathOp newPathOp;
-    newPathOp.mType = iter->mType;
-    if (sPointCount[newPathOp.mType] >= 1) {
-      newPathOp.mP1 = aTransform.TransformPoint(iter->mP1);
-    }
-    if (sPointCount[newPathOp.mType] >= 2) {
-      newPathOp.mP2 = aTransform.TransformPoint(iter->mP2);
-    }
-    if (sPointCount[newPathOp.mType] >= 3) {
-      newPathOp.mP3 = aTransform.TransformPoint(iter->mP3);
-    }
-    recording->mPathOps.push_back(newPathOp);
-  }
+  RefPtr<PathBuilderRecording> recording = new PathBuilderRecording(
+      pathBuilder, mPathOps.TransformedCopy(aTransform), aFillRule);
   return recording.forget();
 }
 
 }  // namespace gfx
 }  // namespace mozilla
diff --git a/gfx/2d/PathRecording.h b/gfx/2d/PathRecording.h
--- a/gfx/2d/PathRecording.h
+++ b/gfx/2d/PathRecording.h
@@ -7,125 +7,220 @@
 #ifndef MOZILLA_GFX_PATHRECORDING_H_
 #define MOZILLA_GFX_PATHRECORDING_H_
 
 #include "2D.h"
 #include <vector>
 #include <ostream>
 
 #include "PathHelpers.h"
+#include "RecordingTypes.h"
 
 namespace mozilla {
 namespace gfx {
 
+class PathOps {
+ public:
+  PathOps() {}
+
+  template <class S>
+  explicit PathOps(S &aStream);
+
+  PathOps(PathOps &&aOther) : mPathData(std::move(aOther.mPathData)) {}
+
+  PathOps(const PathOps &aOther) : mPathData(aOther.mPathData) {}
+
+  PathOps &operator=(PathOps &&aOther) {
+    mPathData = std::move(aOther.mPathData);
+    return *this;
+  }
+
+  template <class S>
+  void Record(S &aStream) const;
+
+  bool StreamToSink(PathSink &aPathSink) const;
+
+  PathOps TransformedCopy(const Matrix &aTransform) const;
+
+  size_t Size() const;
+
+  void MoveTo(const Point &aPoint) { AppendPathOp(OpType::OP_MOVETO, aPoint); }
+
+  void LineTo(const Point &aPoint) { AppendPathOp(OpType::OP_LINETO, aPoint); }
+
+  void BezierTo(const Point &aCP1, const Point &aCP2, const Point &aCP3) {
+    AppendPathOp(OpType::OP_BEZIERTO, ThreePoints{aCP1, aCP2, aCP3});
+  }
+
+  void QuadraticBezierTo(const Point &aCP1, const Point &aCP2) {
+    AppendPathOp(OpType::OP_QUADRATICBEZIERTO, TwoPoints{aCP1, aCP2});
+  }
+
+  void Arc(const Point &aOrigin, float aRadius, float aStartAngle,
+           float aEndAngle, bool aAntiClockwise) {
+    AppendPathOp(OpType::OP_ARC, ArcParams{aOrigin, aRadius, aStartAngle,
+                                           aEndAngle, aAntiClockwise});
+  }
+
+  void Close() {
+    size_t oldSize = mPathData.size();
+    mPathData.resize(oldSize + sizeof(OpType));
+    *reinterpret_cast<OpType *>(mPathData.data() + oldSize) = OpType::OP_CLOSE;
+  }
+
+ private:
+  void operator=(const PathOps &) = delete;  // assign using std::move()!
+
+  enum class OpType : uint32_t {
+    OP_MOVETO = 0,
+    OP_LINETO,
+    OP_BEZIERTO,
+    OP_QUADRATICBEZIERTO,
+    OP_ARC,
+    OP_CLOSE,
+    OP_INVALID
+  };
+
+  template <typename T>
+  void AppendPathOp(const OpType &aOpType, const T &aOpParams) {
+    size_t oldSize = mPathData.size();
+    mPathData.resize(oldSize + sizeof(OpType) + sizeof(T));
+    *reinterpret_cast<OpType *>(mPathData.data() + oldSize) = aOpType;
+    oldSize += sizeof(OpType);
+    *reinterpret_cast<T *>(mPathData.data() + oldSize) = aOpParams;
+  }
+
+  struct TwoPoints {
+    Point p1;
+    Point p2;
+  };
+
+  struct ThreePoints {
+    Point p1;
+    Point p2;
+    Point p3;
+  };
+
+  struct ArcParams {
+    Point origin;
+    float radius;
+    float startAngle;
+    float endAngle;
+    bool antiClockwise;
+  };
+
+  std::vector<uint8_t> mPathData;
+};
+
+template <class S>
+PathOps::PathOps(S &aStream) {
+  ReadVector(aStream, mPathData);
+}
+
+template <class S>
+inline void PathOps::Record(S &aStream) const {
+  WriteVector(aStream, mPathData);
+}
+
 class PathRecording;
 class DrawEventRecorderPrivate;
 
-class PathBuilderRecording : public PathBuilder {
+class PathBuilderRecording final : public PathBuilder {
  public:
   MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(PathBuilderRecording, override)
 
   PathBuilderRecording(PathBuilder *aBuilder, FillRule aFillRule)
       : mPathBuilder(aBuilder), mFillRule(aFillRule) {}
 
+  PathBuilderRecording(PathBuilder *aBuilder, const PathOps &aPathOps,
+                       FillRule aFillRule)
+      : mPathBuilder(aBuilder), mFillRule(aFillRule), mPathOps(aPathOps) {}
+
   /* Move the current point in the path, any figure currently being drawn will
    * be considered closed during fill operations, however when stroking the
    * closing line segment will not be drawn.
    */
-  virtual void MoveTo(const Point &aPoint) override;
+  void MoveTo(const Point &aPoint) final;
+
   /* Add a linesegment to the current figure */
-  virtual void LineTo(const Point &aPoint) override;
+  void LineTo(const Point &aPoint) final;
+
   /* Add a cubic bezier curve to the current figure */
-  virtual void BezierTo(const Point &aCP1, const Point &aCP2,
-                        const Point &aCP3) override;
+  void BezierTo(const Point &aCP1, const Point &aCP2, const Point &aCP3) final;
+
   /* Add a quadratic bezier curve to the current figure */
-  virtual void QuadraticBezierTo(const Point &aCP1, const Point &aCP2) override;
+  void QuadraticBezierTo(const Point &aCP1, const Point &aCP2) final;
+
   /* Close the current figure, this will essentially generate a line segment
    * from the current point to the starting point for the current figure
    */
-  virtual void Close() override;
+  void Close() final;
 
   /* Add an arc to the current figure */
-  virtual void Arc(const Point &aOrigin, float aRadius, float aStartAngle,
-                   float aEndAngle, bool aAntiClockwise) override {
-    ArcToBezier(this, aOrigin, Size(aRadius, aRadius), aStartAngle, aEndAngle,
-                aAntiClockwise);
-  }
+  void Arc(const Point &aOrigin, float aRadius, float aStartAngle,
+           float aEndAngle, bool aAntiClockwise) final;
 
   /* Point the current subpath is at - or where the next subpath will start
    * if there is no active subpath.
    */
-  virtual Point CurrentPoint() const override;
-
-  virtual already_AddRefed<Path> Finish() override;
+  Point CurrentPoint() const final;
 
-  virtual BackendType GetBackendType() const override {
-    return BackendType::RECORDING;
-  }
+  already_AddRefed<Path> Finish() final;
+
+  BackendType GetBackendType() const final { return BackendType::RECORDING; }
 
  private:
-  friend class PathRecording;
-
   RefPtr<PathBuilder> mPathBuilder;
   FillRule mFillRule;
-  std::vector<PathOp> mPathOps;
+  PathOps mPathOps;
 };
 
-class PathRecording : public Path {
+class PathRecording final : public Path {
  public:
   MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(PathRecording, override)
 
-  PathRecording(Path *aPath, const std::vector<PathOp> aOps, FillRule aFillRule)
-      : mPath(aPath), mPathOps(aOps), mFillRule(aFillRule) {}
+  PathRecording(Path *aPath, PathOps &&aOps, FillRule aFillRule)
+      : mPath(aPath), mPathOps(std::move(aOps)), mFillRule(aFillRule) {}
 
   ~PathRecording();
 
-  virtual BackendType GetBackendType() const override {
-    return BackendType::RECORDING;
-  }
-  virtual already_AddRefed<PathBuilder> CopyToBuilder(
-      FillRule aFillRule) const override;
-  virtual already_AddRefed<PathBuilder> TransformedCopyToBuilder(
-      const Matrix &aTransform, FillRule aFillRule) const override;
-  virtual bool ContainsPoint(const Point &aPoint,
-                             const Matrix &aTransform) const override {
+  BackendType GetBackendType() const final { return BackendType::RECORDING; }
+  already_AddRefed<PathBuilder> CopyToBuilder(FillRule aFillRule) const final;
+  already_AddRefed<PathBuilder> TransformedCopyToBuilder(
+      const Matrix &aTransform, FillRule aFillRule) const final;
+  bool ContainsPoint(const Point &aPoint,
+                     const Matrix &aTransform) const final {
     return mPath->ContainsPoint(aPoint, aTransform);
   }
-  virtual bool StrokeContainsPoint(const StrokeOptions &aStrokeOptions,
-                                   const Point &aPoint,
-                                   const Matrix &aTransform) const override {
+  bool StrokeContainsPoint(const StrokeOptions &aStrokeOptions,
+                           const Point &aPoint,
+                           const Matrix &aTransform) const final {
     return mPath->StrokeContainsPoint(aStrokeOptions, aPoint, aTransform);
   }
 
-  virtual Rect GetBounds(const Matrix &aTransform = Matrix()) const override {
+  Rect GetBounds(const Matrix &aTransform = Matrix()) const final {
     return mPath->GetBounds(aTransform);
   }
 
-  virtual Rect GetStrokedBounds(
-      const StrokeOptions &aStrokeOptions,
-      const Matrix &aTransform = Matrix()) const override {
+  Rect GetStrokedBounds(const StrokeOptions &aStrokeOptions,
+                        const Matrix &aTransform = Matrix()) const final {
     return mPath->GetStrokedBounds(aStrokeOptions, aTransform);
   }
 
-  virtual void StreamToSink(PathSink *aSink) const override {
-    mPath->StreamToSink(aSink);
-  }
+  void StreamToSink(PathSink *aSink) const final { mPath->StreamToSink(aSink); }
 
-  virtual FillRule GetFillRule() const override { return mFillRule; }
-
-  void StorePath(std::ostream &aStream) const;
-  static void ReadPathToBuilder(std::istream &aStream, PathBuilder *aBuilder);
+  FillRule GetFillRule() const final { return mFillRule; }
 
  private:
   friend class DrawTargetWrapAndRecord;
   friend class DrawTargetRecording;
   friend class RecordedPathCreation;
 
   RefPtr<Path> mPath;
-  std::vector<PathOp> mPathOps;
+  PathOps mPathOps;
   FillRule mFillRule;
 
   // Event recorders that have this path in their event stream.
   std::vector<RefPtr<DrawEventRecorderPrivate>> mStoredRecorders;
 };
 
 }  // namespace gfx
 }  // namespace mozilla
diff --git a/gfx/2d/RecordedEvent.cpp b/gfx/2d/RecordedEvent.cpp
--- a/gfx/2d/RecordedEvent.cpp
+++ b/gfx/2d/RecordedEvent.cpp
@@ -14,24 +14,28 @@
 #include "ScaledFontBase.h"
 #include "SFNTData.h"
 
 namespace mozilla {
 namespace gfx {
 
 using namespace std;
 
-RecordedEvent *RecordedEvent::LoadEventFromStream(std::istream &aStream,
-                                                  EventType aType) {
-  return LoadEvent(aStream, aType);
+/* static */
+bool RecordedEvent::DoWithEventFromStream(
+    EventStream &aStream, EventType aType,
+    const std::function<bool(RecordedEvent *)> &aAction) {
+  return DoWithEvent(aStream, aType, aAction);
 }
 
-RecordedEvent *RecordedEvent::LoadEventFromStream(EventStream &aStream,
-                                                  EventType aType) {
-  return LoadEvent(aStream, aType);
+/* static */
+bool RecordedEvent::DoWithEventFromStream(
+    EventRingBuffer &aStream, EventType aType,
+    const std::function<bool(RecordedEvent *)> &aAction) {
+  return DoWithEvent(aStream, aType, aAction);
 }
 
 string RecordedEvent::GetEventName(EventType aType) {
   switch (aType) {
     case DRAWTARGETCREATION:
       return "DrawTarget Creation";
     case DRAWTARGETDESTRUCTION:
       return "DrawTarget Destruction";
diff --git a/gfx/2d/RecordedEvent.h b/gfx/2d/RecordedEvent.h
--- a/gfx/2d/RecordedEvent.h
+++ b/gfx/2d/RecordedEvent.h
@@ -11,19 +11,16 @@
 #include <ostream>
 #include <sstream>
 #include <cstring>
 #include <vector>
 
 namespace mozilla {
 namespace gfx {
 
-struct PathOp;
-class PathRecording;
-
 const uint32_t kMagicInt = 0xc001feed;
 
 // A change in major revision means a change in event binary format, causing
 // loss of backwards compatibility. Old streams will not work in a player
 // using a newer major revision. And new streams will not work in a player
 // using an older major revision.
 const uint16_t kMajorRevision = 10;
 // A change in minor revision means additions of new events. New streams will
@@ -144,16 +141,22 @@ struct PatternStorage {
     char *mStorage;
     char mColor[sizeof(ColorPatternStorage)];
     char mLinear[sizeof(LinearGradientPatternStorage)];
     char mRadial[sizeof(RadialGradientPatternStorage)];
     char mSurface[sizeof(SurfacePatternStorage)];
   };
 };
 
+class DataSurfaceProvider {
+ public:
+  virtual already_AddRefed<DataSourceSurface> GetDataSurface(
+      const SourceSurface *aSurface) = 0;
+};
+
 /* SizeCollector and MemWriter are used
  * in a pair to first collect the size of the
  * event that we're going to write and then
  * to write it without checking each individual
  * size. */
 struct SizeCollector {
   SizeCollector() : mTotalSize(0) {}
   void write(const char *, size_t s) { mTotalSize += s; }
@@ -164,16 +167,194 @@ struct MemWriter {
   explicit MemWriter(char *aPtr) : mPtr(aPtr) {}
   void write(const char *aData, size_t aSize) {
     memcpy(mPtr, aData, aSize);
     mPtr += aSize;
   }
   char *mPtr;
 };
 
+// This is a simple interface for an EventRingBuffer, so we can use it in the
+// RecordedEvent reading and writing machinery.
+class EventRingBuffer {
+ public:
+  /**
+   * Templated RecordEvent function so that when we have enough contiguous
+   * space we can record into the buffer quickly using MemWriter.
+   *
+   * @param aRecordedEvent the event to record
+   */
+  template <class RE>
+  void RecordEvent(const RE *aRecordedEvent) {
+    SizeCollector size;
+    aRecordedEvent->Record(size);
+    if (size.mTotalSize > mAvailable) {
+      GetNewWriteBufPos();
+    }
+    if (size.mTotalSize <= mAvailable) {
+      MemWriter writer(mBufPos);
+      aRecordedEvent->Record(writer);
+      UpdateWriteCount(size.mTotalSize);
+      mBufPos += size.mTotalSize;
+      mAvailable -= size.mTotalSize;
+    } else {
+      aRecordedEvent->Record(*this);
+    }
+  }
+
+  /**
+   * Simple write function so that when there is enough space the compiler can
+   * convert the memcpy for the many small fixed sized writes that we have.
+   * If we can't the complexity of the write is deliberately hidden behind a
+   * call to a virtual function.
+   *
+   * @param aData the data to be written to the buffer
+   * @param aSize the number of chars to write
+   */
+  void write(const char *aData, size_t aSize) {
+    if (aSize > mAvailable) {
+      if (!GetNewWriteBufPos()) {
+        return;
+      }
+    }
+
+    if (aSize <= mAvailable) {
+      memcpy(mBufPos, aData, aSize);
+      UpdateWriteCount(aSize);
+      mBufPos += aSize;
+      mAvailable -= aSize;
+      return;
+    }
+
+    WriteInParts(aData, aSize);
+  }
+
+  /**
+   * Simple read function so that when there is enough data available the
+   * compiler can convert the memcpy for the many small fixed sized reads that
+   * we have. If we can't the complexity of the read is deliberately hidden
+   * behind a call to a virtual function.
+   *
+   * @param aOut the pointer to read into
+   * @param aSize the number of chars to read
+   */
+  void read(char *aOut, size_t aSize) {
+    if (aSize > mAvailable) {
+      if (!GetNewReadBufPos()) {
+        return;
+      }
+    }
+
+    if (aSize <= mAvailable) {
+      memcpy(aOut, mBufPos, aSize);
+      UpdateReadCount(aSize);
+      mBufPos += aSize;
+      mAvailable -= aSize;
+      return;
+    }
+
+    ReadInParts(aOut, aSize);
+  }
+
+  virtual bool good() const = 0;
+
+ protected:
+  enum class State : uint32_t {
+    Processing,
+
+    /**
+     * This is the important state to make sure the other side signals or starts
+     * us as soon as data or space is available. We set AboutToWait first and
+     * then re-check the condition. If we went straight to Waiting or Stopped
+     * then in between the last check and setting the state, the other side
+     * could have used all available data or space and never have signaled us
+     * because it didn't know we were about to wait, causing a deadlock.
+     * While we are in this state, the other side must wait until we resolve the
+     * AboutToWait state to one of the other states and then signal or start us
+     * if it needs to.
+     */
+    AboutToWait,
+    Waiting,
+    Stopped
+  };
+
+  /**
+   * Wait until space is available for writing and then set mBufPos and
+   * mAvailable.
+   */
+  virtual bool GetNewWriteBufPos() = 0;
+
+  /**
+   * Write the data into the buffer as space becomes available.
+   *
+   * @param aData the data to be written to the buffer
+   * @param aSize the number of chars to write
+   */
+  virtual void WriteInParts(const char *aData, size_t aSize) = 0;
+
+  /**
+   * Check to see if the reader is waiting or stopped and signal / start it.
+   */
+  virtual void CheckAndSignalReader() = 0;
+
+  /**
+   * Wait until data is available for reading and then set mBufPos and
+   * mAvailable.
+   */
+  virtual bool GetNewReadBufPos() = 0;
+
+  /**
+   * Read data from the buffer as it becomes available.
+   *
+   * @param aOut the pointer to read into
+   * @param aSize the number of chars to read
+   */
+  virtual void ReadInParts(char *aOut, size_t aSize) = 0;
+
+  /**
+   * Check to see if the writer is waiting and signal it.
+   */
+  virtual void CheckAndSignalWriter() = 0;
+
+  void UpdateWriteCount(uint32_t aCount) {
+    mOurCount += aCount;
+    mWrite->count = mOurCount;
+    if (mRead->state != State::Processing) {
+      CheckAndSignalReader();
+    }
+  }
+
+  void UpdateReadCount(uint32_t aCount) {
+    mOurCount += aCount;
+    mRead->count = mOurCount;
+    if (mWrite->state != State::Processing) {
+      CheckAndSignalWriter();
+    }
+  }
+
+  struct ReadFooter {
+    Atomic<uint32_t, ReleaseAcquire> count;
+    Atomic<uint32_t, ReleaseAcquire> returnCount;
+    Atomic<State, ReleaseAcquire> state;
+  };
+
+  struct WriteFooter {
+    Atomic<uint32_t, ReleaseAcquire> count;
+    Atomic<uint32_t, ReleaseAcquire> returnCount;
+    Atomic<uint32_t, ReleaseAcquire> requiredDifference;
+    Atomic<State, ReleaseAcquire> state;
+  };
+
+  char *mBufPos = nullptr;
+  uint32_t mAvailable = 0;
+  WriteFooter *mWrite = nullptr;
+  ReadFooter *mRead = nullptr;
+  uint32_t mOurCount = 0;
+};
+
 struct MemStream {
   char *mData;
   size_t mLength;
   size_t mCapacity;
   void Resize(size_t aSize) {
     mLength = aSize;
     if (mLength > mCapacity) {
       mCapacity = mCapacity * 2;
@@ -194,16 +375,17 @@ struct MemStream {
   MemStream() : mData(nullptr), mLength(0), mCapacity(0) {}
   ~MemStream() { free(mData); }
 };
 
 class EventStream {
  public:
   virtual void write(const char *aData, size_t aSize) = 0;
   virtual void read(char *aOut, size_t aSize) = 0;
+  virtual bool good() = 0;
 };
 
 class RecordedEvent {
  public:
   enum EventType {
     DRAWTARGETCREATION = 0,
     DRAWTARGETDESTRUCTION,
     FILLRECT,
@@ -244,19 +426,20 @@ class RecordedEvent {
     FONTDESC,
     PUSHLAYER,
     PUSHLAYERWITHBLEND,
     POPLAYER,
     UNSCALEDFONTCREATION,
     UNSCALEDFONTDESTRUCTION,
     INTOLUMINANCE,
     EXTERNALSURFACECREATION,
+    FLUSH,
+    DETACHALLSNAPSHOTS,
+    LAST,
   };
-  static const uint32_t kTotalEventTypes =
-      RecordedEvent::FILTERNODESETINPUT + 1;
 
   virtual ~RecordedEvent() {}
 
   static std::string GetEventName(EventType aType);
 
   /**
    * Play back this event using the translator. Note that derived classes
    * should
@@ -267,16 +450,17 @@ class RecordedEvent {
    *                    objects and making playback decisions.
    * @return true unless a fatal problem has occurred and playback should
    * abort.
    */
   virtual bool PlayEvent(Translator *aTranslator) const { return true; }
 
   virtual void RecordToStream(std::ostream &aStream) const = 0;
   virtual void RecordToStream(EventStream &aStream) const = 0;
+  virtual void RecordToStream(EventRingBuffer &aStream) const = 0;
   virtual void RecordToStream(MemStream &aStream) const = 0;
 
   virtual void OutputSimpleEventInfo(std::stringstream &aStringStream) const {}
 
   template <class S>
   void RecordPatternData(S &aStream,
                          const PatternStorage &aPatternStorage) const;
   template <class S>
@@ -285,35 +469,30 @@ class RecordedEvent {
   template <class S>
   void RecordStrokeOptions(S &aStream,
                            const StrokeOptions &aStrokeOptions) const;
   template <class S>
   void ReadStrokeOptions(S &aStream, StrokeOptions &aStrokeOptions);
 
   virtual std::string GetName() const = 0;
 
-  virtual ReferencePtr GetObjectRef() const = 0;
-
   virtual ReferencePtr GetDestinedDT() { return nullptr; }
 
   void OutputSimplePatternInfo(const PatternStorage &aStorage,
                                std::stringstream &aOutput) const;
 
   template <class S>
-  static RecordedEvent *LoadEvent(S &aStream, EventType aType);
-  static RecordedEvent *LoadEventFromStream(std::istream &aStream,
-                                            EventType aType);
-  static RecordedEvent *LoadEventFromStream(EventStream &aStream,
-                                            EventType aType);
-
-  // An alternative to LoadEvent that avoids a heap allocation for the event.
-  // This accepts a callable `f' that will take a RecordedEvent* as a single
-  // parameter
-  template <class S, class F>
-  static bool DoWithEvent(S &aStream, EventType aType, F f);
+  static bool DoWithEvent(S &aStream, EventType aType,
+                          const std::function<bool(RecordedEvent *)> &aAction);
+  static bool DoWithEventFromStream(
+      EventStream &aStream, EventType aType,
+      const std::function<bool(RecordedEvent *)> &aAction);
+  static bool DoWithEventFromStream(
+      EventRingBuffer &aStream, EventType aType,
+      const std::function<bool(RecordedEvent *)> &aAction);
 
   EventType GetType() const { return (EventType)mType; }
 
  protected:
   friend class DrawEventRecorderPrivate;
   friend class DrawEventRecorderFile;
   friend class DrawEventRecorderMemory;
   static void RecordUnscaledFont(UnscaledFont *aUnscaledFont,
@@ -324,12 +503,35 @@ class RecordedEvent {
   static void RecordUnscaledFontImpl(UnscaledFont *aUnscaledFont, S &aOutput);
 
   MOZ_IMPLICIT RecordedEvent(int32_t aType) : mType(aType) {}
 
   int32_t mType;
   std::vector<Float> mDashPatternStorage;
 };
 
+template <class Derived>
+class RecordedEventDerived : public RecordedEvent {
+  using RecordedEvent::RecordedEvent;
+
+ public:
+  void RecordToStream(std::ostream &aStream) const final {
+    static_cast<const Derived *>(this)->Record(aStream);
+  }
+  void RecordToStream(EventStream &aStream) const final {
+    static_cast<const Derived *>(this)->Record(aStream);
+  }
+  void RecordToStream(EventRingBuffer &aStream) const final {
+    aStream.RecordEvent(static_cast<const Derived *>(this));
+  }
+  void RecordToStream(MemStream &aStream) const final {
+    SizeCollector size;
+    static_cast<const Derived *>(this)->Record(size);
+    aStream.Resize(aStream.mLength + size.mTotalSize);
+    MemWriter writer(aStream.mData + aStream.mLength - size.mTotalSize);
+    static_cast<const Derived *>(this)->Record(writer);
+  }
+};
+
 }  // namespace gfx
 }  // namespace mozilla
 
 #endif
diff --git a/gfx/2d/RecordedEventImpl.h b/gfx/2d/RecordedEventImpl.h
--- a/gfx/2d/RecordedEventImpl.h
+++ b/gfx/2d/RecordedEventImpl.h
@@ -16,51 +16,29 @@
 #include "Logging.h"
 #include "ScaledFontBase.h"
 #include "SFNTData.h"
 
 namespace mozilla {
 namespace gfx {
 
 template <class Derived>
-class RecordedEventDerived : public RecordedEvent {
-  using RecordedEvent::RecordedEvent;
-
- public:
-  void RecordToStream(std::ostream &aStream) const override {
-    static_cast<const Derived *>(this)->Record(aStream);
-  }
-  void RecordToStream(EventStream &aStream) const override {
-    static_cast<const Derived *>(this)->Record(aStream);
-  }
-  void RecordToStream(MemStream &aStream) const override {
-    SizeCollector size;
-    static_cast<const Derived *>(this)->Record(size);
-    aStream.Resize(aStream.mLength + size.mTotalSize);
-    MemWriter writer(aStream.mData + aStream.mLength - size.mTotalSize);
-    static_cast<const Derived *>(this)->Record(writer);
-  }
-};
-
-template <class Derived>
 class RecordedDrawingEvent : public RecordedEventDerived<Derived> {
  public:
   virtual ReferencePtr GetDestinedDT() override { return mDT; }
 
  protected:
   RecordedDrawingEvent(RecordedEvent::EventType aType, DrawTarget *aTarget)
       : RecordedEventDerived<Derived>(aType), mDT(aTarget) {}
 
   template <class S>
   RecordedDrawingEvent(RecordedEvent::EventType aType, S &aStream);
   template <class S>
   void Record(S &aStream) const;
 
-  virtual ReferencePtr GetObjectRef() const override;
-
   ReferencePtr mDT;
 };
 
 class RecordedDrawTargetCreation
     : public RecordedEventDerived<RecordedDrawTargetCreation> {
  public:
   RecordedDrawTargetCreation(ReferencePtr aRefPtr, BackendType aType,
                              const IntSize &aSize, SurfaceFormat aFormat,
@@ -77,17 +55,16 @@ class RecordedDrawTargetCreation
   virtual bool PlayEvent(Translator *aTranslator) const override;
 
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "DrawTarget Creation"; }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
   ReferencePtr mRefPtr;
   BackendType mBackendType;
   IntSize mSize;
   SurfaceFormat mFormat;
   bool mHasExistingData;
   RefPtr<SourceSurface> mExistingData;
 
@@ -111,17 +88,16 @@ class RecordedDrawTargetDestruction
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "DrawTarget Destruction";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
   ReferencePtr mRefPtr;
 
   BackendType mBackendType;
 
  private:
   friend class RecordedEvent;
 
@@ -144,17 +120,16 @@ class RecordedCreateSimilarDrawTarget
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "CreateSimilarDrawTarget";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
   ReferencePtr mRefPtr;
   IntSize mSize;
   SurfaceFormat mFormat;
 
  private:
   friend class RecordedEvent;
 
@@ -179,17 +154,16 @@ class RecordedCreateClippedDrawTarget
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "CreateClippedDrawTarget";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
   ReferencePtr mRefPtr;
   IntSize mMaxSize;
   Matrix mTransform;
   SurfaceFormat mFormat;
 
  private:
   friend class RecordedEvent;
@@ -221,17 +195,16 @@ class RecordedCreateDrawTargetForFilter
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "CreateSimilarDrawTargetForFilter";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
   ReferencePtr mRefPtr;
   IntSize mMaxSize;
   SurfaceFormat mFormat;
   ReferencePtr mFilter;
   ReferencePtr mSource;
   Rect mSourceRect;
   Point mDestPoint;
@@ -870,24 +843,24 @@ class RecordedPathCreation : public Reco
   virtual bool PlayEvent(Translator *aTranslator) const override;
 
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "Path Creation"; }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
   FillRule mFillRule;
-  std::vector<PathOp> mPathOps;
+  PathOps *mPathOps;
+  bool mOwnPathOps = false;
 
   template <class S>
   MOZ_IMPLICIT RecordedPathCreation(S &aStream);
 };
 
 class RecordedPathDestruction
     : public RecordedEventDerived<RecordedPathDestruction> {
  public:
@@ -897,17 +870,16 @@ class RecordedPathDestruction
   virtual bool PlayEvent(Translator *aTranslator) const override;
 
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "Path Destruction"; }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
 
   template <class S>
   MOZ_IMPLICIT RecordedPathDestruction(S &aStream);
@@ -934,17 +906,16 @@ class RecordedSourceSurfaceCreation
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "SourceSurface Creation";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
   uint8_t *mData;
   int32_t mStride;
   IntSize mSize;
@@ -966,17 +937,16 @@ class RecordedSourceSurfaceDestruction
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "SourceSurface Destruction";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
 
   template <class S>
   MOZ_IMPLICIT RecordedSourceSurfaceDestruction(S &aStream);
@@ -996,17 +966,16 @@ class RecordedExternalSurfaceCreation
 
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(std::stringstream &aStringStream) const;
 
   virtual std::string GetName() const {
     return "SourceSurfaceSharedData Creation";
   }
-  virtual ReferencePtr GetObjectRef() const { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
   uint64_t mKey;
 
   template <class S>
@@ -1026,17 +995,16 @@ class RecordedFilterNodeCreation
   virtual bool PlayEvent(Translator *aTranslator) const override;
 
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "FilterNode Creation"; }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
   FilterType mType;
 
   template <class S>
@@ -1054,17 +1022,16 @@ class RecordedFilterNodeDestruction
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "FilterNode Destruction";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
 
   template <class S>
   MOZ_IMPLICIT RecordedFilterNodeDestruction(S &aStream);
@@ -1089,17 +1056,16 @@ class RecordedGradientStopsCreation
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "GradientStops Creation";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
   GradientStop *mStops;
   uint32_t mNumStops;
   ExtendMode mExtendMode;
@@ -1120,41 +1086,81 @@ class RecordedGradientStopsDestruction
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "GradientStops Destruction";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
 
   template <class S>
   MOZ_IMPLICIT RecordedGradientStopsDestruction(S &aStream);
 };
 
+class RecordedFlush : public RecordedDrawingEvent<RecordedFlush> {
+ public:
+  explicit RecordedFlush(DrawTarget *aDT) : RecordedDrawingEvent(FLUSH, aDT) {}
+
+  bool PlayEvent(Translator *aTranslator) const final;
+
+  template <class S>
+  void Record(S &aStream) const;
+  virtual void OutputSimpleEventInfo(
+      std::stringstream &aStringStream) const override;
+
+  virtual std::string GetName() const override { return "Flush"; }
+
+ private:
+  friend class RecordedEvent;
+
+  template <class S>
+  MOZ_IMPLICIT RecordedFlush(S &aStream);
+};
+
+class RecordedDetachAllSnapshots
+    : public RecordedDrawingEvent<RecordedDetachAllSnapshots> {
+ public:
+  explicit RecordedDetachAllSnapshots(DrawTarget *aDT)
+      : RecordedDrawingEvent(DETACHALLSNAPSHOTS, aDT) {}
+
+  bool PlayEvent(Translator *aTranslator) const final;
+
+  template <class S>
+  void Record(S &aStream) const;
+  virtual void OutputSimpleEventInfo(
+      std::stringstream &aStringStream) const override;
+
+  virtual std::string GetName() const override { return "DetachAllSnapshots"; }
+
+ private:
+  friend class RecordedEvent;
+
+  template <class S>
+  MOZ_IMPLICIT RecordedDetachAllSnapshots(S &aStream);
+};
+
 class RecordedSnapshot : public RecordedEventDerived<RecordedSnapshot> {
  public:
   RecordedSnapshot(ReferencePtr aRefPtr, DrawTarget *aDT)
       : RecordedEventDerived(SNAPSHOT), mRefPtr(aRefPtr), mDT(aDT) {}
 
   virtual bool PlayEvent(Translator *aTranslator) const override;
 
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "Snapshot"; }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
   ReferencePtr mDT;
 
   template <class S>
@@ -1175,17 +1181,16 @@ class RecordedIntoLuminanceSource
   virtual bool PlayEvent(Translator *aTranslator) const override;
 
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "IntoLuminanceSource"; }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
   ReferencePtr mDT;
   LuminanceType mLuminanceType;
   float mOpacity;
@@ -1218,17 +1223,16 @@ class RecordedFontData : public Recorded
   virtual bool PlayEvent(Translator *aTranslator) const override;
 
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "Font Data"; }
-  virtual ReferencePtr GetObjectRef() const override { return nullptr; };
 
   void SetFontData(const uint8_t *aData, uint32_t aSize, uint32_t aIndex);
 
   bool GetFontDetails(RecordedFontDetails &fontDetails);
 
  private:
   friend class RecordedEvent;
 
@@ -1266,17 +1270,16 @@ class RecordedFontDescriptor
   virtual bool PlayEvent(Translator *aTranslator) const override;
 
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "Font Desc"; }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   void SetFontDescriptor(const uint8_t *aData, uint32_t aSize, uint32_t aIndex);
 
   bool mHasDesc;
 
@@ -1313,17 +1316,16 @@ class RecordedUnscaledFontCreation
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "UnscaledFont Creation";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
   void SetFontInstanceData(const uint8_t *aData, uint32_t aSize);
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
   uint64_t mFontDataKey;
@@ -1344,17 +1346,16 @@ class RecordedUnscaledFontDestruction
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "UnscaledFont Destruction";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
 
   template <class S>
   MOZ_IMPLICIT RecordedUnscaledFontDestruction(S &aStream);
@@ -1384,17 +1385,16 @@ class RecordedScaledFontCreation
   virtual bool PlayEvent(Translator *aTranslator) const override;
 
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "ScaledFont Creation"; }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
   void SetFontInstanceData(const uint8_t *aData, uint32_t aSize,
                            const FontVariation *aVariations,
                            uint32_t aNumVariations);
 
  private:
   friend class RecordedEvent;
 
@@ -1419,17 +1419,16 @@ class RecordedScaledFontDestruction
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override {
     return "ScaledFont Destruction";
   }
-  virtual ReferencePtr GetObjectRef() const override { return mRefPtr; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mRefPtr;
 
   template <class S>
   MOZ_IMPLICIT RecordedScaledFontDestruction(S &aStream);
@@ -1512,17 +1511,16 @@ class RecordedFilterNodeSetAttribute
 
   virtual bool PlayEvent(Translator *aTranslator) const override;
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "SetAttribute"; }
-  virtual ReferencePtr GetObjectRef() const override { return mNode; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mNode;
 
   uint32_t mIndex;
   ArgType mArgType;
@@ -1553,17 +1551,16 @@ class RecordedFilterNodeSetInput
 
   virtual bool PlayEvent(Translator *aTranslator) const override;
   template <class S>
   void Record(S &aStream) const;
   virtual void OutputSimpleEventInfo(
       std::stringstream &aStringStream) const override;
 
   virtual std::string GetName() const override { return "SetInput"; }
-  virtual ReferencePtr GetObjectRef() const override { return mNode; }
 
  private:
   friend class RecordedEvent;
 
   ReferencePtr mNode;
   uint32_t mIndex;
   ReferencePtr mInputFilter;
   ReferencePtr mInputSurface;
@@ -1794,21 +1791,16 @@ RecordedDrawingEvent<T>::RecordedDrawing
 }
 
 template <class T>
 template <class S>
 void RecordedDrawingEvent<T>::Record(S &aStream) const {
   WriteElement(aStream, mDT);
 }
 
-template <class T>
-ReferencePtr RecordedDrawingEvent<T>::GetObjectRef() const {
-  return mDT;
-}
-
 inline bool RecordedDrawTargetCreation::PlayEvent(
     Translator *aTranslator) const {
   RefPtr<DrawTarget> newDT =
       aTranslator->CreateDrawTarget(mRefPtr, mSize, mFormat);
 
   // If we couldn't create a DrawTarget this will probably cause us to crash
   // with nullptr later in the playback, so return false to abort.
   if (!newDT) {
@@ -2737,104 +2729,55 @@ inline void RecordedDrawSurfaceWithShado
                 << ") Color: (" << mColor.r << ", " << mColor.g << ", "
                 << mColor.b << ", " << mColor.a << ")";
 }
 
 inline RecordedPathCreation::RecordedPathCreation(PathRecording *aPath)
     : RecordedEventDerived(PATHCREATION),
       mRefPtr(aPath),
       mFillRule(aPath->mFillRule),
-      mPathOps(aPath->mPathOps) {}
-
-inline RecordedPathCreation::~RecordedPathCreation() {}
+      mPathOps(&aPath->mPathOps),
+      mOwnPathOps(false) {}
+
+inline RecordedPathCreation::~RecordedPathCreation() {
+  if (mOwnPathOps) {
+    delete mPathOps;
+  }
+}
 
 inline bool RecordedPathCreation::PlayEvent(Translator *aTranslator) const {
   RefPtr<PathBuilder> builder =
       aTranslator->GetReferenceDrawTarget()->CreatePathBuilder(mFillRule);
-
-  for (size_t i = 0; i < mPathOps.size(); i++) {
-    const PathOp &op = mPathOps[i];
-    switch (op.mType) {
-      case PathOp::OP_MOVETO:
-        builder->MoveTo(op.mP1);
-        break;
-      case PathOp::OP_LINETO:
-        builder->LineTo(op.mP1);
-        break;
-      case PathOp::OP_BEZIERTO:
-        builder->BezierTo(op.mP1, op.mP2, op.mP3);
-        break;
-      case PathOp::OP_QUADRATICBEZIERTO:
-        builder->QuadraticBezierTo(op.mP1, op.mP2);
-        break;
-      case PathOp::OP_ARC:
-        MOZ_ASSERT_UNREACHABLE("Recordings should not contain arc operations");
-        break;
-      case PathOp::OP_CLOSE:
-        builder->Close();
-        break;
-    }
-  }
+  mPathOps->StreamToSink(*builder);
 
   RefPtr<Path> path = builder->Finish();
   aTranslator->AddPath(mRefPtr, path);
   return true;
 }
 
 template <class S>
 void RecordedPathCreation::Record(S &aStream) const {
   WriteElement(aStream, mRefPtr);
-  WriteElement(aStream, uint64_t(mPathOps.size()));
   WriteElement(aStream, mFillRule);
-  typedef std::vector<PathOp> pathOpVec;
-  for (pathOpVec::const_iterator iter = mPathOps.begin();
-       iter != mPathOps.end(); iter++) {
-    WriteElement(aStream, iter->mType);
-    if (sPointCount[iter->mType] >= 1) {
-      WriteElement(aStream, iter->mP1);
-    }
-    if (sPointCount[iter->mType] >= 2) {
-      WriteElement(aStream, iter->mP2);
-    }
-    if (sPointCount[iter->mType] >= 3) {
-      WriteElement(aStream, iter->mP3);
-    }
-  }
+  mPathOps->Record(aStream);
 }
 
 template <class S>
 RecordedPathCreation::RecordedPathCreation(S &aStream)
     : RecordedEventDerived(PATHCREATION) {
-  uint64_t size;
-
   ReadElement(aStream, mRefPtr);
-  ReadElement(aStream, size);
   ReadElement(aStream, mFillRule);
-
-  for (uint64_t i = 0; i < size; i++) {
-    PathOp newPathOp;
-    ReadElement(aStream, newPathOp.mType);
-    if (sPointCount[newPathOp.mType] >= 1) {
-      ReadElement(aStream, newPathOp.mP1);
-    }
-    if (sPointCount[newPathOp.mType] >= 2) {
-      ReadElement(aStream, newPathOp.mP2);
-    }
-    if (sPointCount[newPathOp.mType] >= 3) {
-      ReadElement(aStream, newPathOp.mP3);
-    }
-
-    mPathOps.push_back(newPathOp);
-  }
+  mPathOps = new PathOps(aStream);
+  mOwnPathOps = true;
 }
 
 inline void RecordedPathCreation::OutputSimpleEventInfo(
     std::stringstream &aStringStream) const {
   aStringStream << "[" << mRefPtr
-                << "] Path created (OpCount: " << mPathOps.size() << ")";
+                << "] Path created (OpCount: " << mPathOps->Size() << ")";
 }
 inline bool RecordedPathDestruction::PlayEvent(Translator *aTranslator) const {
   aTranslator->RemovePath(mRefPtr);
   return true;
 }
 
 template <class S>
 void RecordedPathDestruction::Record(S &aStream) const {
@@ -2872,19 +2815,20 @@ inline bool RecordedSourceSurfaceCreatio
 }
 
 template <class S>
 void RecordedSourceSurfaceCreation::Record(S &aStream) const {
   WriteElement(aStream, mRefPtr);
   WriteElement(aStream, mSize);
   WriteElement(aStream, mFormat);
   MOZ_ASSERT(mData);
-  for (int y = 0; y < mSize.height; y++) {
-    aStream.write((const char *)mData + y * mStride,
-                  BytesPerPixel(mFormat) * mSize.width);
+  size_t dataFormatWidth = BytesPerPixel(mFormat) * mSize.width;
+  const char *endSrc = (const char *)(mData + (mSize.height * mStride));
+  for (const char *src = (const char *)mData; src < endSrc; src += mStride) {
+    aStream.write(src, dataFormatWidth);
   }
 }
 
 template <class S>
 RecordedSourceSurfaceCreation::RecordedSourceSurfaceCreation(S &aStream)
     : RecordedEventDerived(SOURCESURFACECREATION), mDataOwned(true) {
   ReadElement(aStream, mRefPtr);
   ReadElement(aStream, mSize);
@@ -3099,16 +3043,55 @@ RecordedIntoLuminanceSource::RecordedInt
 }
 
 inline void RecordedIntoLuminanceSource::OutputSimpleEventInfo(
     std::stringstream &aStringStream) const {
   aStringStream << "[" << mRefPtr << "] Into Luminance Source (DT: " << mDT
                 << ")";
 }
 
+inline bool RecordedFlush::PlayEvent(Translator *aTranslator) const {
+  aTranslator->LookupDrawTarget(mDT)->Flush();
+  return true;
+}
+
+template <class S>
+void RecordedFlush::Record(S &aStream) const {
+  RecordedDrawingEvent::Record(aStream);
+}
+
+template <class S>
+RecordedFlush::RecordedFlush(S &aStream)
+    : RecordedDrawingEvent(FLUSH, aStream) {}
+
+inline void RecordedFlush::OutputSimpleEventInfo(
+    std::stringstream &aStringStream) const {
+  aStringStream << "[" << mDT << "] Flush";
+}
+
+inline bool RecordedDetachAllSnapshots::PlayEvent(
+    Translator *aTranslator) const {
+  aTranslator->LookupDrawTarget(mDT)->DetachAllSnapshots();
+  return true;
+}
+
+template <class S>
+void RecordedDetachAllSnapshots::Record(S &aStream) const {
+  RecordedDrawingEvent::Record(aStream);
+}
+
+template <class S>
+RecordedDetachAllSnapshots::RecordedDetachAllSnapshots(S &aStream)
+    : RecordedDrawingEvent(DETACHALLSNAPSHOTS, aStream) {}
+
+inline void RecordedDetachAllSnapshots::OutputSimpleEventInfo(
+    std::stringstream &aStringStream) const {
+  aStringStream << "[" << mDT << "] DetachAllSnapshots";
+}
+
 inline bool RecordedSnapshot::PlayEvent(Translator *aTranslator) const {
   RefPtr<SourceSurface> src = aTranslator->LookupDrawTarget(mDT)->Snapshot();
   aTranslator->AddSourceSurface(mRefPtr, src);
   return true;
 }
 
 template <class S>
 void RecordedSnapshot::Record(S &aStream) const {
@@ -3540,20 +3523,16 @@ inline void RecordedFilterNodeSetInput::
     aStringStream << "Filter: " << mInputFilter;
   } else {
     aStringStream << "Surface: " << mInputSurface;
   }
 
   aStringStream << ")";
 }
 
-#define LOAD_EVENT_TYPE(_typeenum, _class) \
-  case _typeenum:                          \
-    return new _class(aStream)
-
 #define FOR_EACH_EVENT(f)                                          \
   f(DRAWTARGETCREATION, RecordedDrawTargetCreation);               \
   f(DRAWTARGETDESTRUCTION, RecordedDrawTargetDestruction);         \
   f(FILLRECT, RecordedFillRect);                                   \
   f(STROKERECT, RecordedStrokeRect);                               \
   f(STROKELINE, RecordedStrokeLine);                               \
   f(CLEARRECT, RecordedClearRect);                                 \
   f(COPYSURFACE, RecordedCopySurface);                             \
@@ -3589,35 +3568,30 @@ inline void RecordedFilterNodeSetInput::
   f(FONTDATA, RecordedFontData);                                   \
   f(FONTDESC, RecordedFontDescriptor);                             \
   f(PUSHLAYER, RecordedPushLayer);                                 \
   f(PUSHLAYERWITHBLEND, RecordedPushLayerWithBlend);               \
   f(POPLAYER, RecordedPopLayer);                                   \
   f(UNSCALEDFONTCREATION, RecordedUnscaledFontCreation);           \
   f(UNSCALEDFONTDESTRUCTION, RecordedUnscaledFontDestruction);     \
   f(INTOLUMINANCE, RecordedIntoLuminanceSource);                   \
-  f(EXTERNALSURFACECREATION, RecordedExternalSurfaceCreation);
-
-template <class S>
-RecordedEvent *RecordedEvent::LoadEvent(S &aStream, EventType aType) {
-  switch (aType) {
-    FOR_EACH_EVENT(LOAD_EVENT_TYPE)
-    default:
-      return nullptr;
-  }
-}
+  f(EXTERNALSURFACECREATION, RecordedExternalSurfaceCreation);     \
+  f(FLUSH, RecordedFlush);                                         \
+  f(DETACHALLSNAPSHOTS, RecordedDetachAllSnapshots);
 
 #define DO_WITH_EVENT_TYPE(_typeenum, _class) \
   case _typeenum: {                           \
     auto e = _class(aStream);                 \
-    return f(&e);                             \
+    return aAction(&e);                       \
   }
 
-template <class S, class F>
-bool RecordedEvent::DoWithEvent(S &aStream, EventType aType, F f) {
+template <class S>
+bool RecordedEvent::DoWithEvent(
+    S &aStream, EventType aType,
+    const std::function<bool(RecordedEvent *)> &aAction) {
   switch (aType) {
     FOR_EACH_EVENT(DO_WITH_EVENT_TYPE)
     default:
       return false;
   }
 }
 
 }  // namespace gfx
diff --git a/gfx/2d/RecordingTypes.h b/gfx/2d/RecordingTypes.h
--- a/gfx/2d/RecordingTypes.h
+++ b/gfx/2d/RecordingTypes.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef MOZILLA_GFX_RECORDINGTYPES_H_
 #define MOZILLA_GFX_RECORDINGTYPES_H_
 
 #include <ostream>
+#include <vector>
 
 namespace mozilla {
 namespace gfx {
 
 template <class S, class T>
 struct ElementStreamFormat {
   static void Write(S &aStream, const T &aElement) {
     aStream.write(reinterpret_cast<const char *>(&aElement), sizeof(T));
@@ -22,16 +23,30 @@ struct ElementStreamFormat {
   }
 };
 
 template <class S, class T>
 void WriteElement(S &aStream, const T &aElement) {
   ElementStreamFormat<S, T>::Write(aStream, aElement);
 }
 template <class S, class T>
+void WriteVector(S &aStream, const std::vector<T> &aVector) {
+  size_t size = aVector.size();
+  WriteElement(aStream, size);
+  aStream.write(reinterpret_cast<const char *>(aVector.data()),
+                sizeof(T) * size);
+}
+template <class S, class T>
 void ReadElement(S &aStream, T &aElement) {
   ElementStreamFormat<S, T>::Read(aStream, aElement);
 }
+template <class S, class T>
+void ReadVector(S &aStream, std::vector<T> &aVector) {
+  size_t size;
+  ReadElement(aStream, size);
+  aVector.resize(size);
+  aStream.read(reinterpret_cast<char *>(aVector.data()), sizeof(T) * size);
+}
 
 }  // namespace gfx
 }  // namespace mozilla
 
 #endif /* MOZILLA_GFX_RECORDINGTYPES_H_ */
diff --git a/gfx/config/gfxVars.h b/gfx/config/gfxVars.h
--- a/gfx/config/gfxVars.h
+++ b/gfx/config/gfxVars.h
@@ -45,17 +45,18 @@ class gfxVarReceiver;
   _(UseWebRenderProgramBinary, bool, false)                        \
   _(UseWebRenderProgramBinaryDisk, bool, false)                    \
   _(WebRenderDebugFlags, int32_t, 0)                               \
   _(ScreenDepth, int32_t, 0)                                       \
   _(GREDirectory, nsString, nsString())                            \
   _(ProfDirectory, nsString, nsString())                           \
   _(UseOMTP, bool, false)                                          \
   _(AllowD3D11KeyedMutex, bool, false)                             \
-  _(SystemTextQuality, int32_t, 5 /* CLEARTYPE_QUALITY */)
+  _(SystemTextQuality, int32_t, 5 /* CLEARTYPE_QUALITY */)         \
+  _(RemoteCanvasEnabled, bool, false)
 
 /* Add new entries above this line. */
 
 // Some graphics settings are computed on the UI process and must be
 // communicated to content and GPU processes. gfxVars helps facilitate
 // this. Its function is similar to gfxPrefs, except rather than hold
 // user preferences, it holds dynamically computed values.
 //
diff --git a/gfx/ipc/GPUParent.cpp b/gfx/ipc/GPUParent.cpp
--- a/gfx/ipc/GPUParent.cpp
+++ b/gfx/ipc/GPUParent.cpp
@@ -204,16 +204,19 @@ mozilla::ipc::IPCResult GPUParent::RecvI
 
   // We bypass gfxPlatform::Init, so we must initialize any relevant libraries
   // here that would normally be initialized there.
   SkGraphics::Init();
 
 #if defined(XP_WIN)
   if (gfxConfig::IsEnabled(Feature::D3D11_COMPOSITING)) {
     DeviceManagerDx::Get()->CreateCompositorDevices();
+    if (gfxVars::RemoteCanvasEnabled()) {
+      MOZ_ALWAYS_TRUE(DeviceManagerDx::Get()->CreateCanvasDevice());
+    }
   }
   if (gfxVars::UseWebRender()) {
     DeviceManagerDx::Get()->CreateDirectCompositionDevice();
     // Ensure to initialize GfxInfo
     nsCOMPtr<nsIGfxInfo> gfxInfo = services::GetGfxInfo();
     Unused << gfxInfo;
 
     Factory::EnsureDWriteFactory();
diff --git a/gfx/layers/CanvasDrawEventRecorder.cpp b/gfx/layers/CanvasDrawEventRecorder.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/CanvasDrawEventRecorder.cpp
@@ -0,0 +1,433 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "CanvasDrawEventRecorder.h"
+
+namespace mozilla {
+namespace layers {
+
+static const int32_t kCheckpointEventType = -1;
+static const uint32_t kMaxSpinCount = 200;
+
+// TODO: These timeouts are long because failure in the middle of writing or
+// reading an event is probably going to be fatal to the GPU process. What we
+// really need to know is whether the other process has died.
+static const TimeDuration kWriterTimeout = TimeDuration::FromMilliseconds(1000);
+static const TimeDuration kReaderTimeout = TimeDuration::FromMilliseconds(5000);
+static const TimeDuration kNoWait = TimeDuration::FromMilliseconds(0);
+
+static const uint32_t kCacheLineSize = 64;
+static const uint32_t kStreamSize = 64 * 1024;
+static const uint32_t kShmemSize = kStreamSize + (2 * kCacheLineSize);
+
+static_assert((static_cast<uint64_t>(UINT32_MAX) + 1) % kStreamSize == 0,
+              "(UINT32_MAX + 1) must be divisible by kStreamSize.");
+
+bool
+CanvasEventRingBuffer::Init(base::ProcessId aOtherPid,
+                            ipc::SharedMemoryBasic::Handle* aReadHandle,
+                            CrossProcessSemaphoreHandle* aReaderSem,
+                            CrossProcessSemaphoreHandle* aWriterSem,
+                            const std::function<void()>& aStartReaderCallback)
+{
+  mSharedMemory = MakeAndAddRef<ipc::SharedMemoryBasic>();
+  if (NS_WARN_IF(!mSharedMemory->Create(kShmemSize)) ||
+      NS_WARN_IF(!mSharedMemory->Map(kShmemSize))) {
+    return false;
+  }
+
+  if (NS_WARN_IF(!mSharedMemory->ShareToProcess(aOtherPid, aReadHandle))) {
+    return false;
+  }
+
+  mSharedMemory->CloseHandle();
+
+  mBuf = static_cast<char*>(mSharedMemory->memory());
+  mBufPos = mBuf;
+  mAvailable = kStreamSize;
+
+  static_assert(sizeof(ReadFooter) <= kCacheLineSize,
+                "ReadFooter must fit in kCacheLineSize.");
+  mRead = reinterpret_cast<ReadFooter*>(mBuf + kStreamSize);
+  mRead->count = 0;
+  mRead->returnCount = 0;
+  mRead->state = State::Processing;
+
+  static_assert(sizeof(WriteFooter) <= kCacheLineSize,
+                "WriteFooter must fit in kCacheLineSize.");
+  mWrite = reinterpret_cast<WriteFooter*>(mBuf + kStreamSize + kCacheLineSize);
+  mWrite->count = 0;
+  mWrite->returnCount = 0;
+  mWrite->requiredDifference = 0;
+  mWrite->state = State::Processing;
+
+  mReaderSemaphore.reset(CrossProcessSemaphore::Create("SharedMemoryStreamParent", 0));
+  *aReaderSem = mReaderSemaphore->ShareToProcess(aOtherPid);
+  mWriterSemaphore.reset(CrossProcessSemaphore::Create("SharedMemoryStreamChild", 0));
+  *aWriterSem = mWriterSemaphore->ShareToProcess(aOtherPid);
+
+  mStartReaderCallback = aStartReaderCallback;
+
+  mGood = true;
+  return true;
+}
+
+bool
+CanvasEventRingBuffer::Init(const ipc::SharedMemoryBasic::Handle& aReadHandle,
+                            const CrossProcessSemaphoreHandle& aReaderSem,
+                            const CrossProcessSemaphoreHandle& aWriterSem)
+{
+  mSharedMemory = MakeAndAddRef<ipc::SharedMemoryBasic>();
+  if (NS_WARN_IF(!mSharedMemory->SetHandle(aReadHandle,
+                                           ipc::SharedMemory::RightsReadWrite)) ||
+      NS_WARN_IF(!mSharedMemory->Map(kShmemSize))) {
+    return false;
+  }
+
+  mSharedMemory->CloseHandle();
+
+  mBuf = static_cast<char*>(mSharedMemory->memory());
+  mRead = reinterpret_cast<ReadFooter*>(mBuf + kStreamSize);
+  mWrite = reinterpret_cast<WriteFooter*>(mBuf + kStreamSize + kCacheLineSize);
+  mReaderSemaphore.reset(CrossProcessSemaphore::Create(aReaderSem));
+  mWriterSemaphore.reset(CrossProcessSemaphore::Create(aWriterSem));
+  mGood = true;
+  return true;
+}
+
+bool
+CanvasEventRingBuffer::GetNewWriteBufPos()
+{
+  uint32_t bufPos = (mOurCount & (kStreamSize - 1));
+  uint32_t maxToWrite = kStreamSize - bufPos;
+  mAvailable = std::min(maxToWrite, WaitForBytesToWrite());
+  if (!mAvailable) {
+    mBufPos = nullptr;
+    return false;
+  }
+
+  mBufPos = mBuf + bufPos;
+  return true;
+}
+
+void
+CanvasEventRingBuffer::WriteInParts(const char* aData, size_t aSize)
+{
+  do {
+    memcpy(mBufPos, aData, mAvailable);
+    UpdateWriteCount(mAvailable);
+    aData += mAvailable;
+    aSize -= mAvailable;
+    if (!GetNewWriteBufPos()) {
+      return;
+    }
+  } while (aSize > mAvailable);
+
+  memcpy(mBufPos, aData, aSize);
+  UpdateWriteCount(aSize);
+  mBufPos += aSize;
+  mAvailable -= aSize;
+}
+
+bool
+CanvasEventRingBuffer::GetNewReadBufPos()
+{
+  uint32_t bufPos = (mOurCount & (kStreamSize - 1));
+  uint32_t maxToRead = kStreamSize - bufPos;
+  mAvailable = std::min(maxToRead, WaitForBytesToRead());
+  if (!mAvailable) {
+    mBufPos = nullptr;
+    return false;
+  }
+
+  mBufPos = mBuf + bufPos;
+  return true;
+}
+
+void
+CanvasEventRingBuffer::ReadInParts(char* aOut, size_t aSize)
+{
+  do {
+    memcpy(aOut, mBufPos, mAvailable);
+    UpdateReadCount(mAvailable);
+    aOut += mAvailable;
+    aSize -= mAvailable;
+    if (!GetNewReadBufPos()) {
+      return;
+    }
+  } while (aSize > mAvailable);
+
+  memcpy(aOut, mBufPos, aSize);
+  UpdateReadCount(aSize);
+  mBufPos += aSize;
+  mAvailable -= aSize;
+}
+
+void
+CanvasEventRingBuffer::CheckAndSignalReader()
+{
+  do {
+    switch (mRead->state) {
+      case State::Processing:
+        return;
+      case State::AboutToWait:
+        // The reader is making a decision about whether to wait. So, we must
+        // wait until it has decided to avoid races.
+        continue;
+      case State::Waiting:
+        if (mRead->count != mOurCount) {
+          // We have to use compareExchange here because the reader can change
+          // from Waiting to Stopped.
+          if (mRead->state.compareExchange(State::Waiting, State::Processing)) {
+            mReaderSemaphore->Signal();
+            return;
+          }
+
+          MOZ_ASSERT(mRead->state == State::Stopped);
+          continue;
+        }
+        return;
+      case State::Stopped:
+        if (mRead->count != mOurCount) {
+          mRead->state = State::Processing;
+          mStartReaderCallback();
+        }
+        return;
+      default:
+        MOZ_ASSERT_UNREACHABLE("Invalid waiting state.");
+        return;
+    }
+  } while (true);
+}
+
+bool
+CanvasEventRingBuffer::HasDataToRead()
+{
+  return (mWrite->count != mOurCount);
+}
+
+bool
+CanvasEventRingBuffer::StopIfEmpty()
+{
+  // Double-check that the writer isn't waiting.
+  CheckAndSignalWriter();
+  mRead->state = State::AboutToWait;
+  if (HasDataToRead()) {
+    mRead->state = State::Processing;
+    return false;
+  }
+
+  mRead->state = State::Stopped;
+  return true;
+}
+
+bool
+CanvasEventRingBuffer::WaitForDataToRead(TimeDuration aTimeout)
+{
+  uint32_t spinCount = kMaxSpinCount;
+  do {
+    if (HasDataToRead()) {
+      return true;
+    }
+  } while (--spinCount != 0);
+
+  // Double-check that the writer isn't waiting.
+  CheckAndSignalWriter();
+  mRead->state = State::AboutToWait;
+  if (HasDataToRead()) {
+    mRead->state = State::Processing;
+    return true;
+  }
+
+  mRead->state = State::Waiting;
+  if (!mReaderSemaphore->Wait(Some(aTimeout))) {
+    // We have to use compareExchange here because the writer can change our
+    // state if we are waiting.
+    if (!mRead->state.compareExchange(State::Waiting, State::Stopped)) {
+      MOZ_ASSERT(HasDataToRead());
+      MOZ_ASSERT(mRead->state == State::Processing);
+      // The writer has just signaled us, so consume it before returning
+      MOZ_ALWAYS_TRUE(mReaderSemaphore->Wait(Some(kNoWait)));
+      return true;
+    }
+
+    return false;
+  }
+
+  MOZ_ASSERT(HasDataToRead());
+
+  return true;
+}
+
+int32_t
+CanvasEventRingBuffer::ReadNextEvent()
+{
+  int32_t nextEvent;
+  ReadElement(*this, nextEvent);
+  while (nextEvent == kCheckpointEventType) {
+    ReadElement(*this, nextEvent);
+  }
+
+  return nextEvent;
+}
+
+uint32_t
+CanvasEventRingBuffer::GetCheckpoint()
+{
+  WriteElement(*this, kCheckpointEventType);
+  return mOurCount;
+}
+
+bool
+CanvasEventRingBuffer::WaitForCheckpoint(uint32_t aCheckpoint,
+                                         TimeDuration aTimeout)
+{
+  return WaitForReadCount(aCheckpoint, aTimeout);
+}
+
+void
+CanvasEventRingBuffer::CheckAndSignalWriter()
+{
+  do {
+    switch (mWrite->state) {
+      case State::Processing:
+        return;
+      case State::AboutToWait:
+        // The writer is making a decision about whether to wait. So, we must
+        // wait until it has decided to avoid races.
+        continue;
+      case State::Waiting:
+        if (mWrite->count - mOurCount <= mWrite->requiredDifference) {
+          mWrite->state = State::Processing;
+          mWriterSemaphore->Signal();
+        }
+        return;
+      default:
+        MOZ_ASSERT_UNREACHABLE("Invalid waiting state.");
+        return;
+    }
+  } while (true);
+}
+
+bool
+CanvasEventRingBuffer::WaitForReadCount(uint32_t aReadCount,
+                                        TimeDuration aTimeout)
+{
+  uint32_t requiredDifference = mOurCount - aReadCount;
+  uint32_t spinCount = kMaxSpinCount;
+  do {
+    if (mOurCount - mRead->count <= requiredDifference) {
+      return true;
+    }
+  } while (--spinCount != 0);
+
+  // Double-check that the reader isn't waiting.
+  CheckAndSignalReader();
+  mWrite->state = State::AboutToWait;
+  if (mOurCount - mRead->count <= requiredDifference) {
+    mWrite->state = State::Processing;
+    return true;
+  }
+
+  mWrite->requiredDifference = requiredDifference;
+  mWrite->state = State::Waiting;
+
+  uint32_t lastReadCount = mRead->count;
+  while (!mWriterSemaphore->Wait(Some(aTimeout))) {
+    if (NS_WARN_IF(mRead->count == lastReadCount)) {
+      return false;
+    }
+    lastReadCount = mRead->count;
+  }
+
+  MOZ_ASSERT(mOurCount - mRead->count <= requiredDifference);
+  return true;
+}
+
+uint32_t
+CanvasEventRingBuffer::WaitForBytesToWrite()
+{
+  uint32_t streamFullReadCount = mOurCount - kStreamSize;
+  if (!WaitForReadCount(streamFullReadCount + 1, kWriterTimeout)) {
+    mGood = false;
+    return 0;
+  }
+
+  return mRead->count - streamFullReadCount;
+}
+
+uint32_t
+CanvasEventRingBuffer::WaitForBytesToRead()
+{
+  if (!WaitForDataToRead(kReaderTimeout)) {
+    mGood = false;
+    return 0;
+  }
+
+  return mWrite->count - mOurCount;
+}
+
+void
+CanvasEventRingBuffer::ReturnWrite(const char* aData, size_t aSize)
+{
+  uint32_t writeCount = mRead->returnCount;
+  uint32_t bufPos = (writeCount & (kStreamSize - 1));
+  uint32_t bufRemaining = kStreamSize - bufPos;
+  uint32_t availableToWrite =
+    std::min(bufRemaining, (mWrite->returnCount + kStreamSize - writeCount));
+  while (availableToWrite < aSize) {
+    if (availableToWrite) {
+      memcpy(mBuf + bufPos, aData, availableToWrite);
+      writeCount += availableToWrite;
+      mRead->returnCount = writeCount;
+      bufPos = (writeCount & (kStreamSize - 1));
+      bufRemaining = kStreamSize - bufPos;
+      aData += availableToWrite;
+      aSize -= availableToWrite;
+    }
+
+    availableToWrite =
+    std::min(bufRemaining, (mWrite->returnCount + kStreamSize - writeCount));
+  }
+
+  memcpy(mBuf + bufPos, aData, aSize);
+  writeCount += aSize;
+  mRead->returnCount = writeCount;
+}
+
+void
+CanvasEventRingBuffer::ReturnRead(char* aOut, size_t aSize)
+{
+  uint32_t readCount = mWrite->returnCount;
+  uint32_t bufPos = (readCount & (kStreamSize - 1));
+  uint32_t bufRemaining = kStreamSize - bufPos;
+  uint32_t availableToRead =
+    std::min(bufRemaining, (mRead->returnCount - readCount));
+  while (availableToRead < aSize) {
+    if (availableToRead) {
+      memcpy(aOut, mBuf + bufPos, availableToRead);
+      readCount += availableToRead;
+      mWrite->returnCount = readCount;
+      bufPos = (readCount & (kStreamSize - 1));
+      bufRemaining = kStreamSize - bufPos;
+      aOut += availableToRead;
+      aSize -= availableToRead;
+    } else {
+      // Double-check that the reader isn't waiting.
+      CheckAndSignalReader();
+    }
+
+    availableToRead =
+      std::min(bufRemaining, (mRead->returnCount - readCount));
+  }
+
+  memcpy(aOut, mBuf + bufPos, aSize);
+  readCount += aSize;
+  mWrite->returnCount = readCount;
+}
+
+} // namespace layers
+} // namespace mozilla
diff --git a/gfx/layers/CanvasDrawEventRecorder.h b/gfx/layers/CanvasDrawEventRecorder.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/CanvasDrawEventRecorder.h
@@ -0,0 +1,198 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_layers_CanvasDrawEventRecorder_h
+#define mozilla_layers_CanvasDrawEventRecorder_h
+
+#include "mozilla/gfx/DrawEventRecorder.h"
+#include "mozilla/ipc/CrossProcessSemaphore.h"
+#include "mozilla/ipc/SharedMemoryBasic.h"
+
+namespace mozilla {
+namespace layers {
+
+class CanvasEventRingBuffer final : public gfx::EventRingBuffer
+{
+public:
+  CanvasEventRingBuffer() {}
+
+  /**
+   * Initialize the write side of a CanvasEventRingBuffer returning handles to
+   * the shared memory for the buffer and the two semaphores for waiting in the
+   * reader and the writer.
+   *
+   * @param aOtherPid process ID to share the handles to
+   * @param aReadHandle handle to the shared memory for the buffer
+   * @param aReaderSem reading blocked semaphore
+   * @param aWriterSem writing blocked semaphore
+   * @param aStartReaderCallback callback to start the reader when it is has
+   *                             stopped
+   * @returns true if initialization succeeds
+   */
+  bool Init(base::ProcessId aOtherPid,
+            ipc::SharedMemoryBasic::Handle* aReadHandle,
+            CrossProcessSemaphoreHandle* aReaderSem,
+            CrossProcessSemaphoreHandle* aWriterSem,
+            const std::function<void()>& aStartReaderCallback);
+
+  /**
+   * Initialize the read side of a CanvasEventRingBuffer.
+   *
+   * @param aReadHandle handle to the shared memory for the buffer
+   * @param aReaderSem reading blocked semaphore
+   * @param aWriterSem writing blocked semaphore
+   * @returns true if initialization succeeds
+   */
+  bool Init(const ipc::SharedMemoryBasic::Handle& aReadHandle,
+            const CrossProcessSemaphoreHandle& aReaderSem,
+            const CrossProcessSemaphoreHandle& aWriterSem);
+
+  bool good() const final { return mGood; }
+
+  bool HasDataToRead();
+
+  /*
+   * This will put the reader into a stopped state if there is no more data to
+   * read. If this returns false the caller is responsible for continuing
+   * translation at a later point. If it returns false the writer will start the
+   * translation again when more data is written.
+   *
+   * @returns true if stopped
+   */
+  bool StopIfEmpty();
+
+  /*
+   * Waits for the given TimeDuration for data to become available.
+   *
+   * @returns true if data is available to read.
+   */
+  bool WaitForDataToRead(TimeDuration aTimeout);
+
+  int32_t ReadNextEvent();
+
+  /**
+   * Writes a checkpoint event to the buffer.
+   *
+   * @returns the write count after the checkpoint has been written
+   */
+  uint32_t GetCheckpoint();
+
+  /**
+   * Waits until the given checkpoint has been read from the buffer.
+   *
+   * @params aCheckpoint the checkpoint to wait for
+   * @params aTimeout duration to wait while reader is not active
+   * @returns true if the checkpoint was reached, false if the read count has
+   *          not changed in the aTimeout duration.
+   */
+  bool WaitForCheckpoint(uint32_t aCheckpoint, TimeDuration aTimeout);
+
+ /**
+   * Used to send data back to the writer. This is done through the same shared
+   * memory so the writer must wait and read the response after it has submitted
+   * the event that uses this.
+   *
+   * @param aData the data to be written back to the writer
+   * @param aSize the number of chars to write
+   */
+  void ReturnWrite(const char* aData, size_t aSize);
+
+ /**
+   * Used to read data sent back from the reader via ReturnWrite. This is done
+   * through the same shared memory so the writer must wait until all expected
+   * data is read before writing new events to the buffer.
+   *
+   * @param aOut the pointer to read into
+   * @param aSize the number of chars to read
+   */
+  void ReturnRead(char* aOut, size_t aSize);
+
+protected:
+  bool GetNewWriteBufPos() final;
+
+  void WriteInParts(const char* aData, size_t aSize) final;
+
+  void CheckAndSignalReader() final;
+
+  bool GetNewReadBufPos() final;
+
+  void ReadInParts(char* aOut, size_t aSize) final;
+
+  void CheckAndSignalWriter() final;
+
+private:
+  CanvasEventRingBuffer(const CanvasEventRingBuffer&) = delete;
+  void operator=(const CanvasEventRingBuffer&) = delete;
+
+  bool WaitForReadCount(uint32_t aReadCount, TimeDuration aTimeout);
+
+  uint32_t WaitForBytesToWrite();
+
+  uint32_t WaitForBytesToRead();
+
+  RefPtr<ipc::SharedMemoryBasic> mSharedMemory;
+  UniquePtr<CrossProcessSemaphore> mReaderSemaphore;
+  UniquePtr<CrossProcessSemaphore> mWriterSemaphore;
+  std::function<void()> mStartReaderCallback;
+  char* mBuf;
+  bool mGood = false;
+};
+
+class CanvasDrawEventRecorder final : public gfx::DrawEventRecorderPrivate
+{
+public:
+  MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(CanvasDrawEventRecorder, final)
+  explicit CanvasDrawEventRecorder() {};
+
+  bool Init(base::ProcessId aOtherPid, ipc::SharedMemoryBasic::Handle* aHandle,
+            CrossProcessSemaphoreHandle* aReaderSem,
+            CrossProcessSemaphoreHandle* aWriterSem,
+            const std::function<void()>& aStartReaderCallback)
+  {
+    return mOutputStream.Init(aOtherPid, aHandle, aReaderSem, aWriterSem,
+                              aStartReaderCallback);
+  }
+
+  void RecordEvent(const gfx::RecordedEvent& aEvent) final
+  {
+    if (!mOutputStream.good()) {
+      return;
+    }
+
+    WriteElement(mOutputStream, aEvent.GetType());
+    aEvent.RecordToStream(mOutputStream);
+  }
+
+  void Flush() final {}
+
+  void ReturnRead(char* aOut, size_t aSize)
+  {
+     mOutputStream.ReturnRead(aOut, aSize);
+  }
+
+  uint32_t GetCheckpoint() { return mOutputStream.GetCheckpoint(); }
+
+  /**
+   * Waits until the given checkpoint has been read by the translator.
+   *
+   * @params aCheckpoint the checkpoint to wait for
+   * @params aTimeout duration to wait while translator is not actively reading
+   * @returns true if the checkpoint was reached, false if the translator has
+   *          not been active in the aTimeout duration.
+   */
+  bool WaitForCheckpoint(uint32_t aCheckpoint, TimeDuration aTimeout)
+  {
+    return mOutputStream.WaitForCheckpoint(aCheckpoint, aTimeout);
+  }
+
+private:
+  CanvasEventRingBuffer mOutputStream;
+};
+
+}
+}
+
+#endif // mozilla_layers_CanvasDrawEventRecorder_h
diff --git a/gfx/layers/CanvasTranslator.cpp b/gfx/layers/CanvasTranslator.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/CanvasTranslator.cpp
@@ -0,0 +1,274 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include "CanvasTranslator.h"
+
+#include "mozilla/gfx/2D.h"
+#include "mozilla/gfx/Logging.h"
+#include "RecordedCanvasEventImpl.h"
+
+#if defined(XP_WIN)
+#include "mozilla/gfx/DeviceManagerDx.h"
+#include "mozilla/layers/TextureD3D11.h"
+#endif
+
+namespace mozilla {
+namespace layers {
+
+// When in a transaction we wait for a short time because we're expecting more
+// events from the content process. We don't want to wait for too long in case
+// other content processes are waiting for events to process.
+static const TimeDuration kReadEventTimeout = TimeDuration::FromMilliseconds(5);
+
+static TextureData*
+CreateTextureData(TextureType aTextureType, const gfx::IntSize &aSize,
+                  gfx::SurfaceFormat aFormat)
+{
+  TextureData* textureData = nullptr;
+  switch (aTextureType) {
+#ifdef XP_WIN
+    case TextureType::DXGI:
+    {
+      RefPtr<ID3D11Device> device =
+        gfx::DeviceManagerDx::Get()->GetCanvasDevice();
+      textureData =
+        D3D11TextureData::Create(aSize, aFormat, ALLOC_CLEAR_BUFFER, device);
+      break;
+    }
+#endif
+    default:
+      MOZ_CRASH("Unsupported TextureType for CanvasTranslator.");
+  }
+
+  if (!textureData) {
+    MOZ_CRASH("Failed to create TextureData.");
+  }
+
+  return textureData;
+}
+
+/* static */
+UniquePtr<CanvasTranslator>
+CanvasTranslator::Create(
+  const TextureType& aTextureType,
+  const ipc::SharedMemoryBasic::Handle& aReadHandle,
+  const CrossProcessSemaphoreHandle& aReaderSem,
+  const CrossProcessSemaphoreHandle& aWriterSem)
+{
+  TextureData* textureData = CreateTextureData(aTextureType,
+                                               gfx::IntSize(1,1),
+                                               gfx::SurfaceFormat::B8G8R8A8);
+  textureData->Lock(OpenMode::OPEN_READ_WRITE);
+  RefPtr<gfx::DrawTarget> dt = textureData->BorrowDrawTarget();
+  return UniquePtr<CanvasTranslator>(
+           new CanvasTranslator(aTextureType, textureData, dt, aReadHandle,
+                                aReaderSem, aWriterSem));
+}
+
+CanvasTranslator::CanvasTranslator(
+  const TextureType& aTextureType,
+  TextureData* aTextureData, gfx::DrawTarget* aDT,
+  const ipc::SharedMemoryBasic::Handle& aReadHandle,
+  const CrossProcessSemaphoreHandle& aReaderSem,
+  const CrossProcessSemaphoreHandle& aWriterSem)
+  : gfx::InlineTranslator(aDT), mTextureType(aTextureType)
+  , mReferenceTextureData(aTextureData)
+{
+  mStream.Init(aReadHandle, aReaderSem, aWriterSem);
+}
+
+CanvasTranslator::~CanvasTranslator()
+{
+  mReferenceTextureData->Unlock();
+}
+
+bool
+CanvasTranslator::TranslateRecording()
+{
+  int32_t eventType = mStream.ReadNextEvent();
+  while (mStream.good()) {
+    bool success =
+      RecordedEvent::DoWithEventFromStream(mStream,
+          static_cast<RecordedEvent::EventType>(eventType),
+          [&] (RecordedEvent* recordedEvent)->bool {
+            // Make sure that the whole event was read from the stream.
+            if (!mStream.good()) {
+              return false;
+            }
+
+            return recordedEvent->PlayEvent(this);
+          });
+
+    if (!success && !HandleExtensionEvent(eventType)) {
+      gfxDevCrash(gfx::LogReason::PlayEventFailed)
+          << "Failed to play canvas event type: " << eventType;
+      mIsValid = false;
+      return true;
+    }
+
+    if (!mIsInTransaction) {
+      return mStream.StopIfEmpty();
+    }
+
+    if (!mStream.HasDataToRead()) {
+      // We're going to wait for the next event, so take the opportunity to
+      // flush the rendering.
+      Flush();
+      if (!mStream.WaitForDataToRead(kReadEventTimeout)) {
+        return true;
+      }
+    }
+
+    eventType = mStream.ReadNextEvent();
+  }
+
+  mIsValid = false;
+  return true;
+}
+
+#define READ_AND_PLAY_CANVAS_EVENT_TYPE(_typeenum, _class) \
+  case _typeenum: { \
+    auto e = _class(mStream); \
+    if (!mStream.good()) { \
+      return false; \
+    } \
+    return e.PlayCanvasEvent(this); \
+  }
+
+bool
+CanvasTranslator::HandleExtensionEvent(int32_t aType)
+{
+  // This is where we handle extensions to the Moz2D Recording events to handle
+  // canvas specific things.
+  switch (aType) {
+    FOR_EACH_CANVAS_EVENT(READ_AND_PLAY_CANVAS_EVENT_TYPE)
+  default:
+    return false;
+  }
+}
+
+void
+CanvasTranslator::BeginTransaction()
+{
+  mIsInTransaction = true;
+}
+
+void
+CanvasTranslator::Flush()
+{
+#if defined(XP_WIN)
+  gfx::AutoMoz2DSerialize moz2dSerialize(
+      GetReferenceDrawTarget()->GetBackendType());
+  RefPtr<ID3D11Device> device = gfx::DeviceManagerDx::Get()->GetCanvasDevice();
+  RefPtr<ID3D11DeviceContext> deviceContext;
+  device->GetImmediateContext(getter_AddRefs(deviceContext));
+  deviceContext->Flush();
+#endif
+}
+
+void
+CanvasTranslator::EndTransaction()
+{
+  Flush();
+  mIsInTransaction = false;
+}
+
+void
+CanvasTranslator::AddTextureData(gfx::ReferencePtr aRefPtr,
+                                 TextureData* atextureData)
+{
+  MonitorAutoLock lock(mTextureDatasMonitor);
+  mTextureDatas[aRefPtr] = UniquePtr<TextureData>(atextureData);
+  mTextureDatasMonitor.Notify();
+}
+
+already_AddRefed<gfx::DrawTarget>
+CanvasTranslator::CreateDrawTarget(gfx::ReferencePtr aRefPtr,
+                                   const gfx::IntSize& aSize,
+                                   gfx::SurfaceFormat aFormat)
+{
+  gfx::AutoMoz2DSerialize moz2dSerialize(
+      GetReferenceDrawTarget()->GetBackendType());
+  TextureData* textureData = CreateTextureData(mTextureType, aSize, aFormat);
+  textureData->Lock(OpenMode::OPEN_READ_WRITE);
+  AddTextureData(aRefPtr, textureData);
+  RefPtr<gfx::DrawTarget> dt = textureData->BorrowDrawTarget();
+  AddDrawTarget(aRefPtr, dt);
+
+  return dt.forget();
+}
+
+void
+CanvasTranslator::RemoveDrawTarget(gfx::ReferencePtr aDrawTarget)
+{
+  InlineTranslator::RemoveDrawTarget(aDrawTarget);
+  MonitorAutoLock lock(mTextureDatasMonitor);
+  gfx::AutoMoz2DSerialize moz2dSerialize(
+      GetReferenceDrawTarget()->GetBackendType());
+  mTextureDatas.erase(aDrawTarget);
+}
+
+TextureData*
+CanvasTranslator::LookupTextureData(gfx::ReferencePtr aDrawTarget)
+{
+  TextureMap::const_iterator result = mTextureDatas.find(aDrawTarget);
+  if (result == mTextureDatas.end()) {
+    return nullptr;
+  }
+  return result->second.get();
+}
+
+TextureData*
+CanvasTranslator::WaitForTextureData(gfx::ReferencePtr aDrawTarget)
+{
+  MonitorAutoLock lock(mTextureDatasMonitor);
+  TextureMap::const_iterator result;
+  while ((result = mTextureDatas.find(aDrawTarget)) == mTextureDatas.end()) {
+    mTextureDatasMonitor.Wait();
+  }
+  return result->second.get();
+}
+
+gfx::DataSourceSurface*
+CanvasTranslator::LookupDataSurface(gfx::ReferencePtr aRefPtr)
+{
+  return mDataSurfaces.GetWeak(aRefPtr);
+}
+
+void
+CanvasTranslator::AddDataSurface(gfx::ReferencePtr aRefPtr,
+                                 RefPtr<gfx::DataSourceSurface>&& aSurface)
+{
+  mDataSurfaces.Put(aRefPtr, aSurface);
+}
+
+void
+CanvasTranslator::RemoveDataSurface(gfx::ReferencePtr aRefPtr)
+{
+  mDataSurfaces.Remove(aRefPtr);
+}
+
+void
+CanvasTranslator::SetPreparedMap(
+  gfx::ReferencePtr aSurface,
+  UniquePtr<gfx::DataSourceSurface::ScopedMap> aMap)
+{
+  mMappedSurface = aSurface;
+  mPreparedMap = std::move(aMap);
+}
+
+UniquePtr<gfx::DataSourceSurface::ScopedMap>
+CanvasTranslator::GetPreparedMap(gfx::ReferencePtr aSurface)
+{
+  MOZ_RELEASE_ASSERT(mMappedSurface == aSurface,
+                     "aSurface must match previously stored surface.");
+
+  mMappedSurface = nullptr;
+  return std::move(mPreparedMap);
+}
+
+} // namespace layers
+} // namespace mozilla
diff --git a/gfx/layers/CanvasTranslator.h b/gfx/layers/CanvasTranslator.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/CanvasTranslator.h
@@ -0,0 +1,213 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_layers_CanvasTranslator_h
+#define mozilla_layers_CanvasTranslator_h
+
+#include <unordered_map>
+#include <vector>
+
+#include "mozilla/gfx/InlineTranslator.h"
+#include "mozilla/layers/CanvasDrawEventRecorder.h"
+#include "mozilla/layers/LayersSurfaces.h"
+#include "mozilla/ipc/CrossProcessSemaphore.h"
+#include "mozilla/Monitor.h"
+#include "mozilla/UniquePtr.h"
+
+namespace mozilla {
+namespace layers {
+
+class TextureData;
+
+class CanvasTranslator final : public gfx::InlineTranslator
+{
+public:
+  /**
+   * Create a canvas translator for a particular TextureType, which translates
+   * events from a CanvasEventRingBuffer.
+   *
+   * @param aTextureType the TextureType the translator will create
+   * @param aReadHandle handle to the shared memory for the CanvasEventRingBuffer
+   * @param aReaderSem reading blocked semaphore for the CanvasEventRingBuffer
+   * @param aWriterSem writing blocked semaphore for the CanvasEventRingBuffer
+   * @returns the new CanvasTranslator
+   */
+  static UniquePtr<CanvasTranslator> Create(
+    const TextureType& aTextureType,
+    const ipc::SharedMemoryBasic::Handle& aReadHandle,
+    const CrossProcessSemaphoreHandle& aReaderSem,
+    const CrossProcessSemaphoreHandle& aWriterSem);
+
+  ~CanvasTranslator();
+
+  bool IsValid() { return mIsValid; }
+
+  /**
+   * Translates events until no more are available or the end of a transaction
+   * If this returns false the caller of this is responsible for re-calling
+   * this function.
+   *
+   * @returns true if all events are processed and false otherwise.
+   */
+  bool TranslateRecording();
+
+  /**
+   * Marks the beginning of rendering for a transaction. While in a transaction
+   * the translator will wait for a short time for events before returning.
+   * When not in a transaction the translator will only translate one event at a
+   * time.
+   */
+  void BeginTransaction();
+
+  /**
+   * Marks the end of a transaction.
+   */
+  void EndTransaction();
+
+  /**
+   * Flushes canvas drawing, for example to a device.
+   */
+  void Flush();
+
+  /**
+   * Used to send data back to the writer. This is done through the same shared
+   * memory so the writer must wait and read the response after it has submitted
+   * the event that uses this.
+   *
+   * @param aData the data to be written back to the writer
+   * @param aSize the number of chars to write
+   */
+  void ReturnWrite(const char* aData, size_t aSize)
+  {
+     mStream.ReturnWrite(aData, aSize);
+  }
+
+  /**
+   * Used during playback of events to create DrawTargets. For the
+   * CanvasTranslator this means creating TextureDatas and getting the
+   * DrawTargets from those.
+   *
+   * @param aRefPtr the key to store the created DrawTarget against
+   * @param aSize the size of the DrawTarget
+   * @param aFormat the surface format for the DrawTarget
+   * @returns the new DrawTarget
+   */
+  already_AddRefed<gfx::DrawTarget>
+    CreateDrawTarget(gfx::ReferencePtr aRefPtr, const gfx::IntSize& aSize,
+                     gfx::SurfaceFormat aFormat) final;
+
+  /**
+   * Get the TextureData associated with a DrawTarget from another process.
+   *
+   * @param aDrawTarget the key used to find the TextureData
+   * @returns the TextureData found
+   */
+  TextureData* LookupTextureData(gfx::ReferencePtr aDrawTarget);
+
+  /**
+   * Waits for the TextureData associated with a DrawTarget from another
+   * to be created and then returns it.
+   *
+   * @param aDrawTarget the key used to find the TextureData
+   * @returns the TextureData found
+   */
+  TextureData* WaitForTextureData(gfx::ReferencePtr aDrawTarget);
+
+  /**
+   * Removes the DrawTarget and other objects associated with a DrawTarget from
+   * another process.
+   *
+   * @param aDrawTarget the key to the objects to remove
+   */
+  void RemoveDrawTarget(gfx::ReferencePtr aDrawTarget) final;
+
+  /**
+   * Removes the SourceSurface and other objects associated with a SourceSurface
+   * from another process.
+   *
+   * @param aRefPtr the key to the objects to remove
+   */
+  void RemoveSourceSurface(gfx::ReferencePtr aRefPtr) final
+  {
+    RemoveDataSurface(aRefPtr);
+    InlineTranslator::RemoveSourceSurface(aRefPtr);
+  }
+
+  /**
+   * Gets the cached DataSourceSurface, if it exists, associated with a
+   * SourceSurface from another process.
+   *
+   * @param aRefPtr the key used to find the DataSourceSurface
+   * @returns the DataSourceSurface or nullptr if not found
+   */
+  gfx::DataSourceSurface* LookupDataSurface(gfx::ReferencePtr aRefPtr);
+
+  /**
+   * Used to cache the DataSourceSurface from a SourceSurface associated with a
+   * SourceSurface from another process. This is to improve performance if we
+   * require the data for that SourceSurface.
+   *
+   * @param aRefPtr the key used to store the DataSourceSurface
+   * @param aSurface the DataSourceSurface to store
+   */
+  void AddDataSurface(gfx::ReferencePtr aRefPtr,
+                      RefPtr<gfx::DataSourceSurface>&& aSurface);
+
+  /**
+   * Gets the cached DataSourceSurface, if it exists, associated with a
+   * SourceSurface from another process.
+   *
+   * @param aRefPtr the key used to find the DataSourceSurface
+   * @returns the DataSourceSurface or nullptr if not found
+   */
+  void RemoveDataSurface(gfx::ReferencePtr aRefPtr);
+
+  /**
+   * Sets a ScopedMap, to be used in a later event.
+   *
+   * @param aSurface the associated surface in the other process
+   * @param aMap the ScopedMap to store
+   */
+  void SetPreparedMap(gfx::ReferencePtr aSurface,
+                      UniquePtr<gfx::DataSourceSurface::ScopedMap> aMap);
+
+  /**
+   * Gets the ScopedMap stored using SetPreparedMap.
+   *
+   * @param aSurface must match the surface from the SetPreparedMap call
+   * @returns the ScopedMap if aSurface matches otherwise nullptr
+   */
+  UniquePtr<gfx::DataSourceSurface::ScopedMap>
+    GetPreparedMap(gfx::ReferencePtr aSurface);
+
+private:
+  CanvasTranslator(const TextureType& aTextureType,
+                   TextureData* aTextureData, gfx::DrawTarget* aDrawTarget,
+                   const ipc::SharedMemoryBasic::Handle& aReadHandle,
+                   const CrossProcessSemaphoreHandle& aReaderSem,
+                   const CrossProcessSemaphoreHandle& aWriterSem);
+
+  void AddTextureData(gfx::ReferencePtr aRefPtr, TextureData* atextureData);
+
+  bool HandleExtensionEvent(int32_t aType);
+
+  CanvasEventRingBuffer mStream;
+  TextureType mTextureType = TextureType::Unknown;
+  UniquePtr<TextureData> mReferenceTextureData;
+  typedef std::unordered_map<void*, UniquePtr<TextureData>> TextureMap;
+  TextureMap mTextureDatas;
+  nsRefPtrHashtable<nsPtrHashKey<void>, gfx::DataSourceSurface> mDataSurfaces;
+  gfx::ReferencePtr mMappedSurface;
+  UniquePtr<gfx::DataSourceSurface::ScopedMap> mPreparedMap;
+  Monitor mTextureDatasMonitor{"CanvasTranslator::mTextureDatasMonitor"};
+  bool mIsValid = true;
+  bool mIsInTransaction = false;
+};
+
+} // namespace layers
+} // namespace mozilla
+
+#endif // mozilla_layers_CanvasTranslator_h
diff --git a/gfx/layers/LayersTypes.h b/gfx/layers/LayersTypes.h
--- a/gfx/layers/LayersTypes.h
+++ b/gfx/layers/LayersTypes.h
@@ -154,16 +154,26 @@ enum class LayersBackend : int8_t {
   LAYERS_BASIC,
   LAYERS_OPENGL,
   LAYERS_D3D11,
   LAYERS_CLIENT,
   LAYERS_WR,
   LAYERS_LAST
 };
 
+enum class TextureType : int8_t {
+  Unknown = 0,
+  DXGI,
+  DIB,
+  X11,
+  MacIOSurface,
+  AndroidNativeWindow,
+  Last
+};
+
 enum class BufferMode : int8_t { BUFFER_NONE, BUFFERED };
 
 enum class DrawRegionClip : int8_t { DRAW, NONE };
 
 enum class SurfaceMode : int8_t {
   SURFACE_NONE = 0,
   SURFACE_OPAQUE,
   SURFACE_SINGLE_CHANNEL_ALPHA,
diff --git a/gfx/layers/PersistentBufferProvider.cpp b/gfx/layers/PersistentBufferProvider.cpp
--- a/gfx/layers/PersistentBufferProvider.cpp
+++ b/gfx/layers/PersistentBufferProvider.cpp
@@ -327,28 +327,33 @@ PersistentBufferProviderShared::BorrowDr
       }
     }
   }
 
   if (!tex || !tex->Lock(OpenMode::OPEN_READ_WRITE)) {
     return nullptr;
   }
 
+  mDrawTarget = tex->BorrowDrawTarget();
   if (mBack != previousBackBuffer && !aPersistedRect.IsEmpty()) {
-    TextureClient* previous = GetTexture(previousBackBuffer);
-    if (previous && previous->Lock(OpenMode::OPEN_READ)) {
-      DebugOnly<bool> success =
-          previous->CopyToTextureClient(tex, &aPersistedRect, nullptr);
-      MOZ_ASSERT(success);
+    if (mPreviousSnapshot) {
+      mDrawTarget->CopySurface(mPreviousSnapshot, aPersistedRect,
+                               gfx::IntPoint(0, 0));
+    } else {
+      TextureClient* previous = GetTexture(previousBackBuffer);
+      if (previous && previous->Lock(OpenMode::OPEN_READ)) {
+        DebugOnly<bool> success =
+            previous->CopyToTextureClient(tex, &aPersistedRect, nullptr);
+        MOZ_ASSERT(success);
 
-      previous->Unlock();
+        previous->Unlock();
+      }
     }
   }
-
-  mDrawTarget = tex->BorrowDrawTarget();
+  mPreviousSnapshot = nullptr;
 
   if (mDrawTarget) {
     // This is simply to ensure the DrawTarget gets initialized, and will detect a
     // device reset, even if we're on the main thread.
     mDrawTarget->ClearRect(Rect(0, 0, 0, 0));
 
     if (!mDrawTarget->IsValid()) {
       mDrawTarget = nullptr;
@@ -361,22 +366,26 @@ PersistentBufferProviderShared::BorrowDr
 
 bool PersistentBufferProviderShared::ReturnDrawTarget(
     already_AddRefed<gfx::DrawTarget> aDT) {
   RefPtr<gfx::DrawTarget> dt(aDT);
   MOZ_ASSERT(mDrawTarget == dt);
   // Can't change the current front buffer while its snapshot is borrowed!
   MOZ_ASSERT(!mSnapshot);
 
+  TextureClient* back = GetTexture(mBack);
+  MOZ_ASSERT(back);
+
+  if (back->HasSynchronization()) {
+    mPreviousSnapshot = back->BorrowSnapshot();
+  }
+
   mDrawTarget = nullptr;
   dt = nullptr;
 
-  TextureClient* back = GetTexture(mBack);
-  MOZ_ASSERT(back);
-
   if (back) {
     back->Unlock();
     mFront = mBack;
   }
 
   return !!back;
 }
 
@@ -390,47 +399,48 @@ TextureClient* PersistentBufferProviderS
   }
   return texture;
 }
 
 already_AddRefed<gfx::SourceSurface>
 PersistentBufferProviderShared::BorrowSnapshot() {
   MOZ_ASSERT(!mDrawTarget);
 
+  if (mPreviousSnapshot) {
+    mSnapshot = mPreviousSnapshot;
+    return do_AddRef(mSnapshot);
+  }
+
   auto front = GetTexture(mFront);
   if (!front || front->IsLocked()) {
     MOZ_ASSERT(false);
     return nullptr;
   }
 
   if (!front->Lock(OpenMode::OPEN_READ)) {
     return nullptr;
   }
 
-  RefPtr<DrawTarget> dt = front->BorrowDrawTarget();
+  mSnapshot = front->BorrowSnapshot();
 
-  if (!dt) {
-    front->Unlock();
-    return nullptr;
-  }
-
-  mSnapshot = dt->Snapshot();
-
-  RefPtr<SourceSurface> snapshot = mSnapshot;
-  return snapshot.forget();
+  return do_AddRef(mSnapshot);
 }
 
 void PersistentBufferProviderShared::ReturnSnapshot(
     already_AddRefed<gfx::SourceSurface> aSnapshot) {
   RefPtr<SourceSurface> snapshot = aSnapshot;
   MOZ_ASSERT(!snapshot || snapshot == mSnapshot);
 
   mSnapshot = nullptr;
   snapshot = nullptr;
 
+  if (mPreviousSnapshot) {
+    return;
+  }
+
   auto front = GetTexture(mFront);
   if (front) {
     front->Unlock();
   }
 }
 
 void PersistentBufferProviderShared::NotifyInactive() {
   ClearCachedResources();
@@ -456,16 +466,17 @@ void PersistentBufferProviderShared::Cle
     if (mTextures.append(front)) {
       mFront = Some<uint32_t>(mTextures.length() - 1);
     }
   }
 }
 
 void PersistentBufferProviderShared::Destroy() {
   mSnapshot = nullptr;
+  mPreviousSnapshot = nullptr;
   mDrawTarget = nullptr;
 
   for (auto& mTexture : mTextures) {
     TextureClient* texture = mTexture;
     if (texture && texture->IsLocked()) {
       MOZ_ASSERT(false);
       texture->Unlock();
     }
diff --git a/gfx/layers/PersistentBufferProvider.h b/gfx/layers/PersistentBufferProvider.h
--- a/gfx/layers/PersistentBufferProvider.h
+++ b/gfx/layers/PersistentBufferProvider.h
@@ -179,16 +179,17 @@ class PersistentBufferProviderShared : p
   Vector<RefPtr<TextureClient>, 4> mTextures;
   // Offset of the texture in mTextures that the canvas uses.
   Maybe<uint32_t> mBack;
   // Offset of the texture in mTextures that is presented to the compositor.
   Maybe<uint32_t> mFront;
 
   RefPtr<gfx::DrawTarget> mDrawTarget;
   RefPtr<gfx::SourceSurface> mSnapshot;
+  RefPtr<gfx::SourceSurface> mPreviousSnapshot;
 };
 
 struct AutoReturnSnapshot {
   PersistentBufferProvider* mBufferProvider;
   RefPtr<gfx::SourceSurface>* mSnapshot;
 
   explicit AutoReturnSnapshot(PersistentBufferProvider* aProvider = nullptr)
       : mBufferProvider(aProvider), mSnapshot(nullptr) {}
diff --git a/gfx/layers/RecordedCanvasEventImpl.h b/gfx/layers/RecordedCanvasEventImpl.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/RecordedCanvasEventImpl.h
@@ -0,0 +1,426 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_layers_RecordedCanvasEventImpl_h
+#define mozilla_layers_RecordedCanvasEventImpl_h
+
+#include "mozilla/gfx/RecordedEvent.h"
+#include "mozilla/gfx/RecordingTypes.h"
+#include "mozilla/layers/CanvasTranslator.h"
+#include "mozilla/layers/CompositorTypes.h"
+#include "mozilla/layers/TextureClient.h"
+
+namespace mozilla {
+namespace layers {
+
+using gfx::DrawTarget;
+using gfx::RecordedEvent;
+using gfx::RecordedEventDerived;
+using gfx::IntSize;
+using EventType = gfx::RecordedEvent::EventType;
+using gfx::ReferencePtr;
+using gfx::SurfaceFormat;
+using gfx::ReadElement;
+using gfx::WriteElement;
+using ipc::SharedMemoryBasic;
+
+const EventType CANVAS_BEGIN_TRANSACTION = EventType::LAST;
+const EventType CANVAS_END_TRANSACTION = EventType(EventType::LAST + 1);
+const EventType CANVAS_FLUSH = EventType(EventType::LAST + 2);
+const EventType TEXTURE_LOCK = EventType(EventType::LAST + 3);
+const EventType TEXTURE_UNLOCK = EventType(EventType::LAST + 4);
+const EventType CACHE_DATA_SURFACE = EventType(EventType::LAST + 5);
+const EventType PREPARE_DATA_FOR_SURFACE = EventType(EventType::LAST + 6);
+const EventType GET_DATA_FOR_SURFACE = EventType(EventType::LAST + 7);
+
+class RecordedCanvasBeginTransaction final
+  : public RecordedEventDerived<RecordedCanvasBeginTransaction> {
+public:
+  RecordedCanvasBeginTransaction()
+  : RecordedEventDerived(CANVAS_BEGIN_TRANSACTION) {}
+
+  template<class S>
+  MOZ_IMPLICIT RecordedCanvasBeginTransaction(S& aStream);
+
+  bool PlayCanvasEvent(CanvasTranslator* aTranslator) const;
+
+  template<class S>
+  void Record(S &aStream) const;
+
+  std::string GetName() const final { return "RecordedCanvasBeginTransaction"; }
+};
+
+inline bool
+RecordedCanvasBeginTransaction::PlayCanvasEvent(
+  CanvasTranslator* aTranslator) const
+{
+  aTranslator->BeginTransaction();
+  return true;
+}
+
+template<class S>
+void
+RecordedCanvasBeginTransaction::Record(S& aStream) const
+{
+}
+
+template<class S>
+RecordedCanvasBeginTransaction::RecordedCanvasBeginTransaction(S& aStream)
+  : RecordedEventDerived(CANVAS_BEGIN_TRANSACTION)
+{
+}
+
+class RecordedCanvasEndTransaction final
+  : public RecordedEventDerived<RecordedCanvasEndTransaction> {
+public:
+  RecordedCanvasEndTransaction()
+  : RecordedEventDerived(CANVAS_END_TRANSACTION) {}
+
+  template<class S>
+  MOZ_IMPLICIT RecordedCanvasEndTransaction(S& aStream);
+
+  bool PlayCanvasEvent(CanvasTranslator* aTranslator) const;
+
+  template<class S>
+  void Record(S &aStream) const;
+
+  std::string GetName() const final { return "RecordedCanvasEndTransaction"; }
+};
+
+inline bool
+RecordedCanvasEndTransaction::PlayCanvasEvent(
+  CanvasTranslator* aTranslator) const
+{
+  aTranslator->EndTransaction();
+  return true;
+}
+
+template<class S>
+void
+RecordedCanvasEndTransaction::Record(S& aStream) const
+{
+}
+
+template<class S>
+RecordedCanvasEndTransaction::RecordedCanvasEndTransaction(S& aStream)
+  : RecordedEventDerived(CANVAS_END_TRANSACTION)
+{
+}
+
+class RecordedCanvasFlush final
+  : public RecordedEventDerived<RecordedCanvasFlush> {
+public:
+  RecordedCanvasFlush()
+  : RecordedEventDerived(CANVAS_FLUSH) {}
+
+  template<class S>
+  MOZ_IMPLICIT RecordedCanvasFlush(S& aStream);
+
+  bool PlayCanvasEvent(CanvasTranslator* aTranslator) const;
+
+  template<class S>
+  void Record(S &aStream) const;
+
+  std::string GetName() const final { return "RecordedCanvasFlush"; }
+};
+
+inline bool
+RecordedCanvasFlush::PlayCanvasEvent(CanvasTranslator* aTranslator) const
+{
+  aTranslator->Flush();
+  return true;
+}
+
+template<class S>
+void
+RecordedCanvasFlush::Record(S& aStream) const
+{
+}
+
+template<class S>
+RecordedCanvasFlush::RecordedCanvasFlush(S& aStream)
+  : RecordedEventDerived(CANVAS_FLUSH)
+{
+}
+
+class RecordedTextureLock final : public RecordedEventDerived<RecordedTextureLock> {
+public:
+  RecordedTextureLock(DrawTarget* aDT, const OpenMode aMode)
+    : RecordedEventDerived(TEXTURE_LOCK), mDT(aDT), mMode(aMode)
+  {}
+
+  template<class S>
+  MOZ_IMPLICIT RecordedTextureLock(S& aStream);
+
+  bool PlayCanvasEvent(CanvasTranslator* aTranslator) const;
+
+  template<class S>
+  void Record(S &aStream) const;
+
+  std::string GetName() const final { return "TextureLock"; }
+
+private:
+  ReferencePtr mDT;
+  OpenMode mMode;
+};
+
+inline bool
+RecordedTextureLock::PlayCanvasEvent(CanvasTranslator* aTranslator) const
+{
+  TextureData* textureData = aTranslator->LookupTextureData(mDT);
+  if (!textureData) {
+    return false;
+  }
+
+  gfx::AutoMoz2DSerialize moz2dSerialize(
+      aTranslator->GetReferenceDrawTarget()->GetBackendType());
+  textureData->Lock(mMode);
+  return true;
+}
+
+template<class S>
+void
+RecordedTextureLock::Record(S& aStream) const
+{
+  WriteElement(aStream, mDT);
+  WriteElement(aStream, mMode);
+}
+
+template<class S>
+RecordedTextureLock::RecordedTextureLock(S& aStream)
+  : RecordedEventDerived(TEXTURE_LOCK)
+{
+  ReadElement(aStream, mDT);
+  ReadElement(aStream, mMode);
+}
+
+class RecordedTextureUnlock final
+  : public RecordedEventDerived<RecordedTextureUnlock> {
+public:
+  explicit RecordedTextureUnlock(DrawTarget* aDT)
+    : RecordedEventDerived(TEXTURE_UNLOCK), mDT(aDT)
+  {}
+
+  template<class S>
+  MOZ_IMPLICIT RecordedTextureUnlock(S& aStream);
+
+  bool PlayCanvasEvent(CanvasTranslator* aTranslator) const;
+
+  template<class S>
+  void Record(S &aStream) const;
+
+  std::string GetName() const final { return "TextureUnlock"; }
+
+private:
+  ReferencePtr mDT;
+};
+
+inline bool
+RecordedTextureUnlock::PlayCanvasEvent(CanvasTranslator* aTranslator) const
+{
+  TextureData* textureData = aTranslator->LookupTextureData(mDT);
+  if (!textureData) {
+    return false;
+  }
+
+  gfx::AutoMoz2DSerialize moz2dSerialize(
+      aTranslator->GetReferenceDrawTarget()->GetBackendType());
+  textureData->Unlock();
+  return true;
+}
+
+template<class S>
+void
+RecordedTextureUnlock::Record(S& aStream) const
+{
+  WriteElement(aStream, mDT);
+}
+
+template<class S>
+RecordedTextureUnlock::RecordedTextureUnlock(S& aStream)
+  : RecordedEventDerived(TEXTURE_UNLOCK)
+{
+  ReadElement(aStream, mDT);
+}
+
+class RecordedCacheDataSurface final
+  : public RecordedEventDerived<RecordedCacheDataSurface> {
+public:
+  explicit RecordedCacheDataSurface(gfx::SourceSurface* aSurface)
+    : RecordedEventDerived(CACHE_DATA_SURFACE) , mSurface(aSurface) {}
+
+  template<class S>
+  MOZ_IMPLICIT RecordedCacheDataSurface(S& aStream);
+
+  bool PlayCanvasEvent(CanvasTranslator* aTranslator) const;
+
+  template<class S>
+  void Record(S &aStream) const;
+
+  std::string GetName() const final { return "RecordedCacheDataSurface"; }
+
+private:
+  ReferencePtr mSurface;
+};
+
+inline bool
+RecordedCacheDataSurface::PlayCanvasEvent(CanvasTranslator* aTranslator) const
+{
+  RefPtr<gfx::SourceSurface> surface =
+    aTranslator->LookupSourceSurface(mSurface);
+
+  RefPtr<gfx::DataSourceSurface> dataSurface = surface->GetDataSurface();
+
+  aTranslator->AddDataSurface(mSurface, std::move(dataSurface));
+  return true;
+}
+
+template<class S>
+void
+RecordedCacheDataSurface::Record(S& aStream) const
+{
+  WriteElement(aStream, mSurface);
+}
+
+template<class S>
+RecordedCacheDataSurface::RecordedCacheDataSurface(S& aStream)
+  : RecordedEventDerived(CACHE_DATA_SURFACE)
+{
+  ReadElement(aStream, mSurface);
+}
+
+class RecordedPrepareDataForSurface final
+  : public RecordedEventDerived<RecordedPrepareDataForSurface> {
+public:
+  explicit RecordedPrepareDataForSurface(const gfx::SourceSurface* aSurface)
+    : RecordedEventDerived(PREPARE_DATA_FOR_SURFACE) , mSurface(aSurface) {}
+
+  template<class S>
+  MOZ_IMPLICIT RecordedPrepareDataForSurface(S& aStream);
+
+  bool PlayCanvasEvent(CanvasTranslator* aTranslator) const;
+
+  template<class S>
+  void Record(S &aStream) const;
+
+  std::string GetName() const final { return "RecordedPrepareDataForSurface"; }
+
+private:
+  ReferencePtr mSurface;
+};
+
+inline bool
+RecordedPrepareDataForSurface::PlayCanvasEvent(CanvasTranslator* aTranslator) const
+{
+  RefPtr<gfx::DataSourceSurface> dataSurface =
+    aTranslator->LookupDataSurface(mSurface);
+  if (!dataSurface) {
+    RefPtr<gfx::SourceSurface> surface =
+      aTranslator->LookupSourceSurface(mSurface);
+    if (!surface) {
+      return false;
+    }
+
+    dataSurface = surface->GetDataSurface();
+    if (!dataSurface) {
+      return false;
+    }
+  }
+
+  auto preparedMap = MakeUnique<gfx::DataSourceSurface::ScopedMap>(dataSurface,
+                         gfx::DataSourceSurface::READ);
+  aTranslator->SetPreparedMap(mSurface, std::move(preparedMap));
+
+  return true;
+}
+
+template<class S>
+void
+RecordedPrepareDataForSurface::Record(S& aStream) const
+{
+  WriteElement(aStream, mSurface);
+}
+
+template<class S>
+RecordedPrepareDataForSurface::RecordedPrepareDataForSurface(S& aStream)
+  : RecordedEventDerived(PREPARE_DATA_FOR_SURFACE)
+{
+  ReadElement(aStream, mSurface);
+}
+
+class RecordedGetDataForSurface final
+  : public RecordedEventDerived<RecordedGetDataForSurface> {
+public:
+  explicit RecordedGetDataForSurface(const gfx::SourceSurface* aSurface)
+    : RecordedEventDerived(GET_DATA_FOR_SURFACE) , mSurface(aSurface) {}
+
+  template<class S>
+  MOZ_IMPLICIT RecordedGetDataForSurface(S& aStream);
+
+  bool PlayCanvasEvent(CanvasTranslator* aTranslator) const;
+
+  template<class S>
+  void Record(S &aStream) const;
+
+  std::string GetName() const final { return "RecordedGetDataForSurface"; }
+
+private:
+  ReferencePtr mSurface;
+};
+
+inline bool
+RecordedGetDataForSurface::PlayCanvasEvent(CanvasTranslator* aTranslator) const
+{
+  RefPtr<gfx::SourceSurface> surface =
+      aTranslator->LookupSourceSurface(mSurface);
+  if (!surface) {
+    return false;
+  }
+
+  UniquePtr<gfx::DataSourceSurface::ScopedMap> map =
+      aTranslator->GetPreparedMap(mSurface);
+
+  gfx::IntSize ssSize = surface->GetSize();
+  size_t dataFormatWidth = ssSize.width * BytesPerPixel(surface->GetFormat());
+  int32_t srcStride = map->GetStride();
+  char* src = reinterpret_cast<char*>(map->GetData());
+  char* endSrc = src + (ssSize.height * srcStride);
+  while (src < endSrc) {
+    aTranslator->ReturnWrite(src, dataFormatWidth);
+    src += srcStride;
+  }
+
+  return true;
+}
+
+template<class S>
+void
+RecordedGetDataForSurface::Record(S& aStream) const
+{
+  WriteElement(aStream, mSurface);
+}
+
+template<class S>
+RecordedGetDataForSurface::RecordedGetDataForSurface(S& aStream)
+  : RecordedEventDerived(GET_DATA_FOR_SURFACE)
+{
+  ReadElement(aStream, mSurface);
+}
+
+#define FOR_EACH_CANVAS_EVENT(f) \
+    f(CANVAS_BEGIN_TRANSACTION, RecordedCanvasBeginTransaction); \
+    f(CANVAS_END_TRANSACTION, RecordedCanvasEndTransaction); \
+    f(CANVAS_FLUSH, RecordedCanvasFlush); \
+    f(TEXTURE_LOCK, RecordedTextureLock); \
+    f(TEXTURE_UNLOCK, RecordedTextureUnlock); \
+    f(CACHE_DATA_SURFACE, RecordedCacheDataSurface); \
+    f(PREPARE_DATA_FOR_SURFACE, RecordedPrepareDataForSurface); \
+    f(GET_DATA_FOR_SURFACE, RecordedGetDataForSurface);
+
+} // namespace layers
+} // namespace mozilla
+
+#endif // mozilla_layers_RecordedCanvasEventImpl_h
diff --git a/gfx/layers/client/ClientLayerManager.cpp b/gfx/layers/client/ClientLayerManager.cpp
--- a/gfx/layers/client/ClientLayerManager.cpp
+++ b/gfx/layers/client/ClientLayerManager.cpp
@@ -649,16 +649,18 @@ void ClientLayerManager::StopFrameTimeRe
     renderer->SendStopFrameTimeRecording(aStartIndex, &aFrameIntervals);
   }
 }
 
 void ClientLayerManager::ForwardTransaction(bool aScheduleComposite) {
   AUTO_PROFILER_TRACING("Paint", "ForwardTransaction", GRAPHICS);
   TimeStamp start = TimeStamp::Now();
 
+  GetCompositorBridgeChild()->EndCanvasTransaction();
+
   // Skip the synchronization for buffer since we also skip the painting during
   // device-reset status. With OMTP, we have to wait for async paints
   // before we synchronize and it's done on the paint thread.
   RefPtr<SyncObjectClient> syncObject = nullptr;
   if (!gfxPlatform::GetPlatform()->DidRenderingDeviceReset()) {
     if (mForwarder->GetSyncObject() &&
         mForwarder->GetSyncObject()->IsSyncObjectValid()) {
       syncObject = mForwarder->GetSyncObject();
@@ -846,17 +848,19 @@ void ClientLayerManager::RemoveDidCompos
 already_AddRefed<PersistentBufferProvider>
 ClientLayerManager::CreatePersistentBufferProvider(const gfx::IntSize& aSize,
                                                    gfx::SurfaceFormat aFormat) {
   // Don't use a shared buffer provider if compositing is considered "not cheap"
   // because the canvas will most likely be flattened into a thebes layer
   // instead of being sent to the compositor, in which case rendering into
   // shared memory is wasteful.
   if (IsCompositingCheap() &&
-      gfxPrefs::PersistentBufferProviderSharedEnabled()) {
+      (gfxPrefs::PersistentBufferProviderSharedEnabled() ||
+       TextureData::IsRemote(GetCompositorBackendType(),
+                             BackendSelector::Canvas))) {
     RefPtr<PersistentBufferProvider> provider =
         PersistentBufferProviderShared::Create(aSize, aFormat,
                                                AsShadowForwarder());
     if (provider) {
       return provider.forget();
     }
   }
 
diff --git a/gfx/layers/client/TextureClient.cpp b/gfx/layers/client/TextureClient.cpp
--- a/gfx/layers/client/TextureClient.cpp
+++ b/gfx/layers/client/TextureClient.cpp
@@ -4,39 +4,42 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/layers/TextureClient.h"
 #include <stdint.h>  // for uint8_t, uint32_t, etc
 #include "Layers.h"  // for Layer, etc
 #include "gfx2DGlue.h"
 #include "gfxPlatform.h"  // for gfxPlatform
+#include "MainThreadUtils.h"
 #include "mozilla/Atomics.h"
 #include "mozilla/SystemGroup.h"
 #include "mozilla/ipc/SharedMemory.h"  // for SharedMemory, etc
 #include "mozilla/layers/CompositableForwarder.h"
 #include "mozilla/layers/ISurfaceAllocator.h"
 #include "mozilla/layers/ImageBridgeChild.h"
 #include "mozilla/layers/ImageDataSerializer.h"
 #include "mozilla/layers/PaintThread.h"
 #include "mozilla/layers/TextureClientRecycleAllocator.h"
+#include "mozilla/layers/TextureRecorded.h"
 #include "mozilla/Mutex.h"
 #include "nsDebug.h"          // for NS_ASSERTION, NS_WARNING, etc
 #include "nsISupportsImpl.h"  // for MOZ_COUNT_CTOR, etc
 #include "ImageContainer.h"   // for PlanarYCbCrData, etc
 #include "mozilla/gfx/2D.h"
 #include "mozilla/gfx/Logging.h"  // for gfxDebug
 #include "mozilla/layers/TextureClientOGL.h"
 #include "mozilla/layers/PTextureChild.h"
 #include "mozilla/gfx/DataSurfaceHelpers.h"  // for CreateDataSourceSurfaceByCloning
 #include "nsPrintfCString.h"                 // for nsPrintfCString
 #include "LayersLogging.h"                   // for AppendToString
 #include "gfxUtils.h"                        // for gfxUtils::GetAsLZ4Base64Str
 #include "IPDLActor.h"
 #include "BufferTexture.h"
+#include "mozilla/gfx/gfxVars.h"
 #include "gfxPrefs.h"
 #include "mozilla/layers/ShadowLayers.h"
 #include "mozilla/ipc/CrossProcessSemaphore.h"
 
 #ifdef XP_WIN
 #  include "mozilla/gfx/DeviceManagerDx.h"
 #  include "mozilla/layers/TextureD3D11.h"
 #  include "mozilla/layers/TextureDIB.h"
@@ -230,16 +233,162 @@ class TextureChild final : PTextureChild
   bool mIPCOpen;
   bool mOwnsTextureData;
   bool mOwnerCalledDestroy;
 
   friend class TextureClient;
   friend void DeallocateTextureClient(TextureDeallocParams params);
 };
 
+static inline gfx::BackendType BackendTypeForBackendSelector(
+    LayersBackend aLayersBackend, BackendSelector aSelector) {
+  switch (aSelector) {
+    case BackendSelector::Canvas:
+      return gfxPlatform::GetPlatform()->GetPreferredCanvasBackend();
+    case BackendSelector::Content:
+      return gfxPlatform::GetPlatform()->GetContentBackendFor(aLayersBackend);
+    default:
+      MOZ_ASSERT_UNREACHABLE("Unknown backend selector");
+      return gfx::BackendType::NONE;
+  }
+};
+
+static TextureType GetTextureType(gfx::SurfaceFormat aFormat,
+                                  gfx::IntSize aSize,
+                                  LayersBackend aLayersBackend,
+                                  gfx::BackendType aBackendType,
+                                  int32_t aMaxTextureSize,
+                                  TextureAllocationFlags aAllocFlags) {
+#ifdef XP_WIN
+  if ((aLayersBackend == LayersBackend::LAYERS_D3D11 ||
+       aLayersBackend == LayersBackend::LAYERS_WR) &&
+      (aBackendType == gfx::BackendType::DIRECT2D ||
+       aBackendType == gfx::BackendType::DIRECT2D1_1 ||
+       (!!(aAllocFlags & ALLOC_FOR_OUT_OF_BAND_CONTENT) &&
+        DeviceManagerDx::Get()->GetContentDevice())) &&
+      aSize.width <= aMaxTextureSize && aSize.height <= aMaxTextureSize &&
+      !(aAllocFlags & ALLOC_UPDATE_FROM_SURFACE)) {
+    return TextureType::DXGI;
+  }
+
+  if (aLayersBackend != LayersBackend::LAYERS_WR &&
+      aFormat == SurfaceFormat::B8G8R8X8 &&
+      aBackendType == gfx::BackendType::CAIRO && NS_IsMainThread()) {
+    return TextureType::DIB;
+  }
+#endif
+
+#ifdef MOZ_X11
+  gfxSurfaceType type =
+      gfxPlatform::GetPlatform()->ScreenReferenceSurface()->GetType();
+
+  if (aLayersBackend == LayersBackend::LAYERS_BASIC &&
+      aBackendType == gfx::BackendType::CAIRO && type == gfxSurfaceType::Xlib) {
+    return TextureType::X11;
+  }
+  if (aLayersBackend == LayersBackend::LAYERS_OPENGL &&
+      type == gfxSurfaceType::Xlib && aFormat != SurfaceFormat::A8 &&
+      gl::sGLXLibrary.UseTextureFromPixmap()) {
+    return TextureType::X11;
+  }
+#endif
+
+#ifdef XP_MACOSX
+  if (gfxPrefs::UseIOSurfaceTextures()) {
+    return TextureType::MacIOSurface;
+  }
+#endif
+
+#ifdef MOZ_WIDGET_ANDROID
+  if (gfxPrefs::UseSurfaceTextureTextures()) {
+    return TextureType::AndroidNativeWindow;
+  }
+#endif
+
+  return TextureType::Unknown;
+}
+
+static bool ShouldRemoteTextureType(TextureType aTextureType,
+                                    BackendSelector aSelector) {
+  if (!XRE_IsContentProcess()) {
+    return false;
+  }
+
+  if (aSelector != BackendSelector::Canvas || !gfxVars::RemoteCanvasEnabled()) {
+    return false;
+  }
+
+  switch (aTextureType) {
+    case TextureType::DXGI:
+      return true;
+    default:
+      return false;
+  }
+}
+
+/* static */
+TextureData* TextureData::Create(TextureForwarder* aAllocator,
+                                 gfx::SurfaceFormat aFormat, gfx::IntSize aSize,
+                                 LayersBackend aLayersBackend,
+                                 int32_t aMaxTextureSize,
+                                 BackendSelector aSelector,
+                                 TextureFlags aTextureFlags,
+                                 TextureAllocationFlags aAllocFlags) {
+  gfx::BackendType moz2DBackend =
+      BackendTypeForBackendSelector(aLayersBackend, aSelector);
+
+  TextureType textureType =
+      GetTextureType(aFormat, aSize, aLayersBackend, moz2DBackend,
+                     aMaxTextureSize, aAllocFlags);
+
+  if (ShouldRemoteTextureType(textureType, aSelector)) {
+    RefPtr<CanvasChild> canvasChild = aAllocator->GetCanvasChild();
+    if (canvasChild) {
+      return new RecordedTextureData(canvasChild.forget(), aSize, aFormat,
+                                     textureType);
+    }
+  }
+
+  switch (textureType) {
+#ifdef XP_WIN
+    case TextureType::DXGI:
+      return DXGITextureData::Create(aSize, aFormat, aAllocFlags);
+    case TextureType::DIB:
+      return DIBTextureData::Create(aSize, aFormat, aAllocator);
+#endif
+#ifdef MOZ_X11
+    case TextureType::X11:
+      return X11TextureData::Create(aSize, aFormat, aTextureFlags, aAllocator);
+#endif
+#ifdef XP_MACOSX
+    case TextureType::MacIOSurface:
+      return MacIOSurfaceTextureData::Create(aSize, aFormat, moz2DBackend);
+#endif
+#ifdef MOZ_WIDGET_ANDROID
+    case TextureType::AndroidNativeWindow:
+      return AndroidNativeWindowTextureData::Create(aSize, aFormat);
+#endif
+    default:
+      return nullptr;
+  }
+}
+
+/* static */
+bool TextureData::IsRemote(LayersBackend aLayersBackend,
+                           BackendSelector aSelector) {
+  gfx::BackendType moz2DBackend =
+      BackendTypeForBackendSelector(aLayersBackend, aSelector);
+
+  TextureType textureType = GetTextureType(
+      gfx::SurfaceFormat::UNKNOWN, gfx::IntSize(1, 1), aLayersBackend,
+      moz2DBackend, INT32_MAX, TextureAllocationFlags::ALLOC_DEFAULT);
+
+  return ShouldRemoteTextureType(textureType, aSelector);
+}
+
 static void DestroyTextureData(TextureData* aTextureData,
                                LayersIPCChannel* aAllocator, bool aDeallocate,
                                bool aMainThreadOnly) {
   if (!aTextureData) {
     return;
   }
 
   if (aMainThreadOnly && !NS_IsMainThread()) {
@@ -679,16 +828,27 @@ gfx::DrawTarget* TextureClient::BorrowDr
 #ifdef DEBUG
     mExpectedDtRefs = mBorrowedDrawTarget ? mBorrowedDrawTarget->refCount() : 0;
 #endif
   }
 
   return mBorrowedDrawTarget;
 }
 
+already_AddRefed<gfx::SourceSurface> TextureClient::BorrowSnapshot() {
+  MOZ_ASSERT(mIsLocked);
+
+  RefPtr<gfx::SourceSurface> surface = mData->BorrowSnapshot();
+  if (!surface) {
+    surface = BorrowDrawTarget()->Snapshot();
+  }
+
+  return surface.forget();
+}
+
 bool TextureClient::BorrowMappedData(MappedTextureData& aMap) {
   MOZ_ASSERT(IsValid());
 
   // TODO - SharedRGBImage just accesses the buffer without properly locking
   // the texture. It's bad.
   // MOZ_ASSERT(mIsLocked);
   // if (!mIsLocked) {
   //  return nullptr;
@@ -988,29 +1148,16 @@ bool TextureClient::InitIPDLActor(KnowsC
     LockActor();
   }
 
   return mActor->IPCOpen();
 }
 
 PTextureChild* TextureClient::GetIPDLActor() { return mActor; }
 
-static inline gfx::BackendType BackendTypeForBackendSelector(
-    LayersBackend aLayersBackend, BackendSelector aSelector) {
-  switch (aSelector) {
-    case BackendSelector::Canvas:
-      return gfxPlatform::GetPlatform()->GetPreferredCanvasBackend();
-    case BackendSelector::Content:
-      return gfxPlatform::GetPlatform()->GetContentBackendFor(aLayersBackend);
-    default:
-      MOZ_ASSERT_UNREACHABLE("Unknown backend selector");
-      return gfx::BackendType::NONE;
-  }
-};
-
 // static
 already_AddRefed<TextureClient> TextureClient::CreateForDrawing(
     KnowsCompositor* aAllocator, gfx::SurfaceFormat aFormat, gfx::IntSize aSize,
     BackendSelector aSelector, TextureFlags aTextureFlags,
     TextureAllocationFlags aAllocFlags) {
   LayersBackend layersBackend = aAllocator->GetCompositorBackendType();
   if (aAllocator->SupportsTextureDirectMapping() &&
       std::max(aSize.width, aSize.height) <= aAllocator->GetMaxTextureSize()) {
@@ -1035,63 +1182,19 @@ already_AddRefed<TextureClient> TextureC
   if (!aAllocator || !aAllocator->IPCOpen()) {
     return nullptr;
   }
 
   if (!gfx::Factory::AllowedSurfaceSize(aSize)) {
     return nullptr;
   }
 
-  TextureData* data = nullptr;
-
-#ifdef XP_WIN
-  if ((aLayersBackend == LayersBackend::LAYERS_D3D11 ||
-       aLayersBackend == LayersBackend::LAYERS_WR) &&
-      (moz2DBackend == gfx::BackendType::DIRECT2D ||
-       moz2DBackend == gfx::BackendType::DIRECT2D1_1 ||
-       (!!(aAllocFlags & ALLOC_FOR_OUT_OF_BAND_CONTENT) &&
-        DeviceManagerDx::Get()->GetContentDevice())) &&
-      aSize.width <= aMaxTextureSize && aSize.height <= aMaxTextureSize &&
-      !(aAllocFlags & ALLOC_UPDATE_FROM_SURFACE)) {
-    data = DXGITextureData::Create(aSize, aFormat, aAllocFlags);
-  }
-
-  if (aLayersBackend != LayersBackend::LAYERS_WR && !data &&
-      aFormat == SurfaceFormat::B8G8R8X8 &&
-      moz2DBackend == gfx::BackendType::CAIRO && NS_IsMainThread()) {
-    data = DIBTextureData::Create(aSize, aFormat, aAllocator);
-  }
-#endif
-
-#ifdef MOZ_X11
-  gfxSurfaceType type =
-      gfxPlatform::GetPlatform()->ScreenReferenceSurface()->GetType();
-
-  if (!data && aLayersBackend == LayersBackend::LAYERS_BASIC &&
-      moz2DBackend == gfx::BackendType::CAIRO && type == gfxSurfaceType::Xlib) {
-    data = X11TextureData::Create(aSize, aFormat, aTextureFlags, aAllocator);
-  }
-  if (!data && aLayersBackend == LayersBackend::LAYERS_OPENGL &&
-      type == gfxSurfaceType::Xlib && aFormat != SurfaceFormat::A8 &&
-      gl::sGLXLibrary.UseTextureFromPixmap()) {
-    data = X11TextureData::Create(aSize, aFormat, aTextureFlags, aAllocator);
-  }
-#endif
-
-#ifdef XP_MACOSX
-  if (!data && gfxPrefs::UseIOSurfaceTextures()) {
-    data = MacIOSurfaceTextureData::Create(aSize, aFormat, moz2DBackend);
-  }
-#endif
-
-#ifdef MOZ_WIDGET_ANDROID
-  if (!data && gfxPrefs::UseSurfaceTextureTextures()) {
-    data = AndroidNativeWindowTextureData::Create(aSize, aFormat);
-  }
-#endif
+  TextureData* data = TextureData::Create(
+      aAllocator, aFormat, aSize, aLayersBackend, aMaxTextureSize, aSelector,
+      aTextureFlags, aAllocFlags);
 
   if (data) {
     return MakeAndAddRef<TextureClient>(data, aTextureFlags, aAllocator);
   }
 
   // Can't do any better than a buffer texture client.
   return TextureClient::CreateForRawBufferAccess(aAllocator, aFormat, aSize,
                                                  moz2DBackend, aLayersBackend,
diff --git a/gfx/layers/client/TextureClient.h b/gfx/layers/client/TextureClient.h
--- a/gfx/layers/client/TextureClient.h
+++ b/gfx/layers/client/TextureClient.h
@@ -242,30 +242,41 @@ class TextureData {
         : format(gfx::SurfaceFormat::UNKNOWN),
           hasIntermediateBuffer(false),
           hasSynchronization(false),
           supportsMoz2D(false),
           canExposeMappedData(false),
           canConcurrentlyReadLock(true) {}
   };
 
-  TextureData() { MOZ_COUNT_CTOR(TextureData); }
+  static TextureData* Create(TextureForwarder* aAllocator,
+                             gfx::SurfaceFormat aFormat, gfx::IntSize aSize,
+                             LayersBackend aLayersBackend,
+                             int32_t aMaxTextureSize, BackendSelector aSelector,
+                             TextureFlags aTextureFlags,
+                             TextureAllocationFlags aAllocFlags);
+
+  static bool IsRemote(LayersBackend aLayersBackend, BackendSelector aSelector);
 
   virtual ~TextureData() { MOZ_COUNT_DTOR(TextureData); }
 
   virtual void FillInfo(TextureData::Info& aInfo) const = 0;
 
   virtual bool Lock(OpenMode aMode) = 0;
 
   virtual void Unlock() = 0;
 
   virtual already_AddRefed<gfx::DrawTarget> BorrowDrawTarget() {
     return nullptr;
   }
 
+  virtual already_AddRefed<gfx::SourceSurface> BorrowSnapshot() {
+    return nullptr;
+  }
+
   virtual bool BorrowMappedData(MappedTextureData&) { return false; }
 
   virtual bool BorrowMappedYCbCrData(MappedYCbCrTextureData&) { return false; }
 
   virtual void Deallocate(LayersIPCChannel* aAllocator) = 0;
 
   /// Depending on the texture's flags either Deallocate or Forget is called.
   virtual void Forget(LayersIPCChannel* aAllocator) {}
@@ -297,16 +308,19 @@ class TextureData {
 #ifdef XP_WIN
   virtual D3D11TextureData* AsD3D11TextureData() { return nullptr; }
   virtual DXGIYCbCrTextureData* AsDXGIYCbCrTextureData() { return nullptr; }
 #endif
 
   virtual BufferTextureData* AsBufferTextureData() { return nullptr; }
 
   virtual GPUVideoTextureData* AsGPUVideoTextureData() { return nullptr; }
+
+ protected:
+  TextureData() { MOZ_COUNT_CTOR(TextureData); }
 };
 
 /**
  * TextureClient is a thin abstraction over texture data that need to be shared
  * between the content process and the compositor process. It is the
  * content-side half of a TextureClient/TextureHost pair. A corresponding
  * TextureHost lives on the compositor-side.
  *
@@ -427,16 +441,18 @@ class TextureClient : public AtomicRefCo
    *   DrawTarget* dt = texture->BorrowDrawTarget();
    *   // use the draw target ...
    * }
    * texture->Unlock();
    *
    */
   gfx::DrawTarget* BorrowDrawTarget();
 
+  already_AddRefed<gfx::SourceSurface> BorrowSnapshot();
+
   /**
    * Similar to BorrowDrawTarget but provides direct access to the texture's
    * bits instead of a DrawTarget.
    */
   bool BorrowMappedData(MappedTextureData&);
   bool BorrowMappedYCbCrData(MappedYCbCrTextureData&);
 
   /**
diff --git a/gfx/layers/client/TextureRecorded.cpp b/gfx/layers/client/TextureRecorded.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/client/TextureRecorded.cpp
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "TextureRecorded.h"
+
+#include "RecordedCanvasEventImpl.h"
+
+namespace mozilla {
+namespace layers {
+
+RecordedTextureData::RecordedTextureData(
+  already_AddRefed<CanvasChild> aCanvasChild, gfx::IntSize aSize,
+  gfx::SurfaceFormat aFormat, TextureType aTextureType)
+  : mCanvasChild(aCanvasChild)
+  , mSize(aSize)
+  , mFormat(aFormat)
+{
+  mCanvasChild->EnsureRecorder(aTextureType);
+}
+
+RecordedTextureData::~RecordedTextureData()
+{
+}
+
+void
+RecordedTextureData::FillInfo(TextureData::Info& aInfo) const
+{
+  aInfo.size = mSize;
+  aInfo.format = mFormat;
+  aInfo.supportsMoz2D = true;
+  aInfo.hasIntermediateBuffer = false;
+  aInfo.hasSynchronization = true;
+}
+
+bool
+RecordedTextureData::Lock(OpenMode aMode)
+{
+  mCanvasChild->EnsureBeginTransaction();
+  if (!mDT) {
+    mDT = mCanvasChild->CreateDrawTarget(mSize, mFormat);
+
+    // We lock the TextureData when we create it to get the remote DrawTarget.
+    mCanvasChild->OnTextureWriteLock();
+    return true;
+  }
+
+  mCanvasChild->RecordEvent(RecordedTextureLock(mDT.get(), aMode));
+  if (aMode & OpenMode::OPEN_WRITE) {
+    mCanvasChild->OnTextureWriteLock();
+    mSnapshot = nullptr;
+  }
+  return true;
+}
+
+void
+RecordedTextureData::Unlock()
+{
+  mCanvasChild->RecordEvent(RecordedTextureUnlock(mDT.get()));
+}
+
+already_AddRefed<gfx::DrawTarget>
+RecordedTextureData::BorrowDrawTarget()
+{
+  return do_AddRef(mDT);
+}
+
+already_AddRefed<gfx::SourceSurface>
+RecordedTextureData::BorrowSnapshot()
+{
+  MOZ_ASSERT(mDT);
+
+  if (!mSnapshot) {
+    mSnapshot = mDT->Snapshot();
+  }
+
+  return do_AddRef(mSnapshot);
+}
+
+void
+RecordedTextureData::Deallocate(LayersIPCChannel* aAllocator)
+{
+}
+
+bool
+RecordedTextureData::Serialize(SurfaceDescriptor& aDescriptor)
+{
+  SurfaceDescriptorRecorded descriptor;
+  descriptor.drawTarget() = reinterpret_cast<uintptr_t>(mDT.get());
+  aDescriptor = std::move(descriptor);
+  return true;
+}
+
+void
+RecordedTextureData::OnForwardedToHost()
+{
+  mCanvasChild->OnTextureForwarded();
+  if (mSnapshot && mCanvasChild->ShouldCacheDataSurface()) {
+    mCanvasChild->RecordEvent(RecordedCacheDataSurface(mSnapshot.get()));
+  }
+}
+
+} // namespace layers
+} // namespace mozilla
diff --git a/gfx/layers/client/TextureRecorded.h b/gfx/layers/client/TextureRecorded.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/client/TextureRecorded.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_layers_TextureRecorded_h
+#define mozilla_layers_TextureRecorded_h
+
+#include "TextureClient.h"
+#include "mozilla/layers/CanvasChild.h"
+
+namespace mozilla {
+namespace layers {
+
+class RecordedTextureData final : public TextureData
+{
+public:
+  RecordedTextureData(already_AddRefed<CanvasChild> aCanvasChild,
+                      gfx::IntSize aSize, gfx::SurfaceFormat aFormat,
+                      TextureType aTextureType);
+
+  void FillInfo(TextureData::Info& aInfo) const final;
+
+  bool Lock(OpenMode aMode) final;
+
+  void Unlock() final;
+
+  already_AddRefed<gfx::DrawTarget> BorrowDrawTarget() final;
+
+  already_AddRefed<gfx::SourceSurface> BorrowSnapshot() final;
+
+  void Deallocate(LayersIPCChannel* aAllocator) final;
+
+  bool Serialize(SurfaceDescriptor& aDescriptor) final;
+
+  void OnForwardedToHost() final;
+
+private:
+  DISALLOW_COPY_AND_ASSIGN(RecordedTextureData);
+
+  ~RecordedTextureData() override;
+
+  RefPtr<CanvasChild> mCanvasChild;
+  gfx::IntSize mSize;
+  gfx::SurfaceFormat mFormat;
+  RefPtr<gfx::DrawTarget> mDT;
+  RefPtr<gfx::SourceSurface> mSnapshot;
+};
+
+} // namespace layers
+} // namespace mozilla
+
+#endif // mozilla_layers_TextureRecorded_h
diff --git a/gfx/layers/composite/TextureHost.cpp b/gfx/layers/composite/TextureHost.cpp
--- a/gfx/layers/composite/TextureHost.cpp
+++ b/gfx/layers/composite/TextureHost.cpp
@@ -225,16 +225,31 @@ already_AddRefed<TextureHost> TextureHos
 #endif
 
 #ifdef XP_WIN
     case SurfaceDescriptor::TSurfaceDescriptorD3D10:
     case SurfaceDescriptor::TSurfaceDescriptorDXGIYCbCr:
       result = CreateTextureHostD3D11(aDesc, aDeallocator, aBackend, aFlags);
       break;
 #endif
+    case SurfaceDescriptor::TSurfaceDescriptorRecorded: {
+      const SurfaceDescriptorRecorded& desc =
+          aDesc.get_SurfaceDescriptorRecorded();
+      TextureData* data =
+          aDeallocator->AsCompositorBridgeParentBase()
+              ->LookupTextureDataForClientDrawTarget(desc.drawTarget());
+      SurfaceDescriptor realDesc;
+      if (!data->Serialize(realDesc)) {
+        MOZ_CRASH("Failed to serialize");
+      }
+
+      result = TextureHost::Create(realDesc, aReadLock, aDeallocator, aBackend,
+                                   aFlags, aExternalImageId);
+      return result.forget();
+    }
     default:
       MOZ_CRASH("GFX: Unsupported Surface type host");
   }
 
   if (result && WrapWithWebRenderTextureHost(aDeallocator, aBackend, aFlags)) {
     MOZ_ASSERT(aExternalImageId.isSome());
     result =
         new WebRenderTextureHost(aDesc, aFlags, result, aExternalImageId.ref());
diff --git a/gfx/layers/d3d11/TextureD3D11.cpp b/gfx/layers/d3d11/TextureD3D11.cpp
--- a/gfx/layers/d3d11/TextureD3D11.cpp
+++ b/gfx/layers/d3d11/TextureD3D11.cpp
@@ -731,17 +731,18 @@ already_AddRefed<TextureHost> CreateText
       break;
     }
     default: { MOZ_ASSERT_UNREACHABLE("Unsupported SurfaceDescriptor type"); }
   }
   return result.forget();
 }
 
 already_AddRefed<DrawTarget> D3D11TextureData::BorrowDrawTarget() {
-  MOZ_ASSERT(NS_IsMainThread() || PaintThread::IsOnPaintThread());
+  MOZ_ASSERT(NS_IsMainThread() || PaintThread::IsOnPaintThread() ||
+             NS_IsInCanvasThread());
 
   if (!mDrawTarget && mTexture) {
     // This may return a null DrawTarget
     mDrawTarget = Factory::CreateDrawTargetForD3D11Texture(mTexture, mFormat);
     if (!mDrawTarget) {
       gfxCriticalNote << "Could not borrow DrawTarget (D3D11) " << (int)mFormat;
     }
   }
diff --git a/gfx/layers/ipc/CanvasChild.cpp b/gfx/layers/ipc/CanvasChild.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/CanvasChild.cpp
@@ -0,0 +1,175 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "CanvasChild.h"
+
+#include "MainThreadUtils.h"
+#include "mozilla/gfx/DrawTargetRecording.h"
+#include "mozilla/gfx/Tools.h"
+#include "mozilla/layers/CanvasDrawEventRecorder.h"
+#include "RecordedCanvasEventImpl.h"
+
+namespace mozilla {
+namespace layers {
+
+static const TimeDuration kLockWaitTimeout = TimeDuration::FromMilliseconds(100);
+static const TimeDuration kGetDataTimeout = TimeDuration::FromMilliseconds(500);
+
+CanvasChild::CanvasChild(Endpoint<PCanvasChild>&& aEndpoint)
+{
+  aEndpoint.Bind(this);
+  mCanSend = true;
+}
+
+CanvasChild::~CanvasChild()
+{
+}
+
+void
+CanvasChild::EnsureRecorder(TextureType aTextureType)
+{
+  if (!mRecorder) {
+    MOZ_ASSERT(mTextureType == TextureType::Unknown);
+    mTextureType = aTextureType;
+    mRecorder = MakeAndAddRef<CanvasDrawEventRecorder>();
+    SharedMemoryBasic::Handle handle;
+    CrossProcessSemaphoreHandle readerSem;
+    CrossProcessSemaphoreHandle writerSem;
+    RefPtr<CanvasChild> thisRef = this;
+    mRecorder->Init(OtherPid(), &handle, &readerSem, &writerSem,
+                    [cc = std::move(thisRef)] { cc->StartTranslation(); });
+
+    if (mCanSend) {
+      Unused << SendCreateTranslator(mTextureType, handle, readerSem,
+                                     writerSem);
+    }
+  }
+
+  MOZ_RELEASE_ASSERT(mTextureType == aTextureType,
+                     "We only support one remote TextureType currently.");
+}
+
+void
+CanvasChild::ActorDestroy(ActorDestroyReason aWhy)
+{
+  mCanSend = false;
+
+  // Explicitly drop our reference to the recorder, because it holds a reference
+  // to us via the StartTranslation callback.
+  mRecorder = nullptr;
+}
+
+void
+CanvasChild::StartTranslation()
+{
+  if (mCanSend) {
+    SendStartTranslation();
+  }
+}
+
+void
+CanvasChild::Destroy()
+{
+  Close();
+}
+
+void
+CanvasChild::OnTextureWriteLock()
+{
+  mHasOutstandingWriteLock = true;
+  mLastWriteLockCheckpoint = mRecorder->GetCheckpoint();
+}
+
+void
+CanvasChild::OnTextureForwarded()
+{
+  if (mHasOutstandingWriteLock) {
+    mRecorder->RecordEvent(RecordedCanvasFlush());
+    if (!mRecorder->WaitForCheckpoint(mLastWriteLockCheckpoint,
+                                      kLockWaitTimeout)) {
+      gfxWarning() << "Timed out waiting for last write lock to be processed.";
+    }
+
+    mHasOutstandingWriteLock = false;
+  }
+}
+
+void
+CanvasChild::EnsureBeginTransaction()
+{
+  if (!mIsInTransaction) {
+    mRecorder->RecordEvent(RecordedCanvasBeginTransaction());
+    mIsInTransaction = true;
+  }
+}
+
+void
+CanvasChild::EndTransaction()
+{
+  if (mIsInTransaction) {
+    mRecorder->RecordEvent(RecordedCanvasEndTransaction());
+    mIsInTransaction = false;
+  }
+
+  ++mTransactionsSinceGetDataSurface;
+}
+
+already_AddRefed<gfx::DrawTarget>
+CanvasChild::CreateDrawTarget(gfx::IntSize aSize, gfx::SurfaceFormat aFormat)
+{
+  MOZ_ASSERT(mRecorder);
+
+  RefPtr<gfx::DrawTarget> dummyDt =
+    gfx::Factory::CreateDrawTarget(gfx::BackendType::SKIA, gfx::IntSize(1, 1),
+                                   aFormat);
+  RefPtr<gfx::DrawTarget> dt =
+    MakeAndAddRef<gfx::DrawTargetRecording>(mRecorder, dummyDt, aSize, false,
+                                            this);
+  return dt.forget();
+}
+
+void
+CanvasChild::RecordEvent(const gfx::RecordedEvent& aEvent)
+{
+  mRecorder->RecordEvent(aEvent);
+}
+
+already_AddRefed<gfx::DataSourceSurface>
+CanvasChild::GetDataSurface(const gfx::SourceSurface* aSurface)
+{
+  MOZ_ASSERT(aSurface);
+
+  mTransactionsSinceGetDataSurface = 0;
+  EnsureBeginTransaction();
+  mRecorder->RecordEvent(RecordedPrepareDataForSurface(aSurface));
+  uint32_t checkpoint = mRecorder->GetCheckpoint();
+
+  gfx::IntSize ssSize = aSurface->GetSize();
+  gfx::SurfaceFormat ssFormat = aSurface->GetFormat();
+  size_t dataFormatWidth = ssSize.width * BytesPerPixel(ssFormat);
+  RefPtr<gfx::DataSourceSurface> dataSurface =
+      gfx::Factory::CreateDataSourceSurfaceWithStride(ssSize, ssFormat,
+                                                      dataFormatWidth);
+  if (!dataSurface) {
+    gfxWarning() << "Failed to create DataSourceSurface.";
+    return nullptr;
+  }
+  gfx::DataSourceSurface::ScopedMap map(dataSurface,
+                                        gfx::DataSourceSurface::READ_WRITE);
+  char* dest = reinterpret_cast<char*>(map.GetData());
+  if (!mRecorder->WaitForCheckpoint(checkpoint, kGetDataTimeout)) {
+    gfxWarning() << "Timed out preparing data for DataSourceSurface.";
+    return dataSurface.forget();
+  }
+
+  mRecorder->RecordEvent(RecordedGetDataForSurface(aSurface));
+  mRecorder->ReturnRead(dest, ssSize.height * dataFormatWidth);
+
+  return dataSurface.forget();
+}
+
+} // namespace layers
+} // namespace mozilla
diff --git a/gfx/layers/ipc/CanvasChild.h b/gfx/layers/ipc/CanvasChild.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/CanvasChild.h
@@ -0,0 +1,88 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_layers_CanvasChild_h
+#define mozilla_layers_CanvasChild_h
+
+#include "mozilla/gfx/RecordedEvent.h"
+#include "mozilla/ipc/CrossProcessSemaphore.h"
+#include "mozilla/layers/PCanvasChild.h"
+#include "mozilla/layers/SourceSurfaceSharedData.h"
+#include "nsRefPtrHashtable.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+
+namespace gfx {
+class SourceSurface;
+}
+
+namespace layers {
+class CanvasDrawEventRecorder;
+
+class CanvasChild final : public PCanvasChild,
+                          public gfx::DataSurfaceProvider
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(CanvasChild)
+
+  explicit CanvasChild(Endpoint<PCanvasChild>&& aEndpoint);
+
+  /**
+   * Ensures that the DrawEventRecorder has been created.
+   *
+   * @params aTextureType the TextureType to create in the CanvasTranslator.
+   */
+  void EnsureRecorder(TextureType aTextureType);
+
+  void StartTranslation();
+
+  void Destroy();
+
+  void OnTextureWriteLock();
+
+  void OnTextureForwarded();
+
+  bool ShouldCacheDataSurface() const
+  {
+    return mTransactionsSinceGetDataSurface < kCacheDataSurfaceThreshold;
+  }
+
+  void EnsureBeginTransaction();
+
+  void EndTransaction();
+
+  already_AddRefed<gfx::DrawTarget>
+    CreateDrawTarget(gfx::IntSize aSize, gfx::SurfaceFormat aFormat);
+
+  void RecordEvent(const gfx::RecordedEvent& aEvent);
+
+  already_AddRefed<gfx::DataSourceSurface>
+    GetDataSurface(const gfx::SourceSurface* aSurface) final;
+
+protected:
+  void ActorDestroy(ActorDestroyReason aWhy) final;
+
+private:
+  DISALLOW_COPY_AND_ASSIGN(CanvasChild);
+
+  ~CanvasChild() final;
+
+  static const uint32_t kCacheDataSurfaceThreshold = 10;
+
+  RefPtr<CanvasDrawEventRecorder> mRecorder;
+  TextureType mTextureType = TextureType::Unknown;
+  uint32_t mLastWriteLockCheckpoint = 0;
+  uint32_t mTransactionsSinceGetDataSurface = kCacheDataSurfaceThreshold;
+  bool mCanSend = false;
+  bool mIsInTransaction = false;
+  bool mHasOutstandingWriteLock = false;
+};
+
+} // namespace layers
+} // namespace mozilla
+
+#endif // mozilla_layers_CanvasChild_h
diff --git a/gfx/layers/ipc/CanvasParent.cpp b/gfx/layers/ipc/CanvasParent.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/CanvasParent.cpp
@@ -0,0 +1,189 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "CanvasParent.h"
+
+#include "base/thread.h"
+#include "mozilla/layers/SourceSurfaceSharedData.h"
+#include "mozilla/layers/TextureClient.h"
+#include "mozilla/SharedThreadPool.h"
+#include "prsystem.h"
+
+#if defined(XP_WIN)
+#include "mozilla/gfx/DeviceManagerDx.h"
+#include "mozilla/layers/DeviceAttachmentsD3D11.h"
+#endif
+
+bool
+NS_IsInCanvasThread()
+{
+  return mozilla::layers::CanvasParent::IsInCanvasThread();
+}
+
+namespace mozilla {
+namespace layers {
+
+static base::Thread* sCanvasThread = nullptr;
+static StaticRefPtr<nsIThreadPool> sCanvasWorkers;
+static bool sShuttingDown = false;
+
+static MessageLoop*
+CanvasPlaybackLoop()
+{
+  if (!sCanvasThread && !sShuttingDown) {
+    MOZ_ASSERT(NS_IsInCompositorThread());
+    base::Thread* canvasThread = new base::Thread("Canvas");
+    if (canvasThread->Start()) {
+      sCanvasThread = canvasThread;
+    }
+  }
+
+  return sCanvasThread ? sCanvasThread->message_loop() : nullptr;
+}
+
+/* static */
+already_AddRefed<CanvasParent>
+CanvasParent::Create(ipc::Endpoint<PCanvasParent>&& aEndpoint)
+{
+  MOZ_ASSERT(NS_IsInCompositorThread());
+
+  if (sShuttingDown) {
+    return nullptr;
+  }
+
+  RefPtr<CanvasParent> canvasParent = new CanvasParent();
+  if (CanvasPlaybackLoop()->IsAcceptingTasks()) {
+    RefPtr<Runnable> runnable =
+        NewRunnableMethod<Endpoint<PCanvasParent>&&>(
+          "CanvasParent::Bind",
+          canvasParent,
+          &CanvasParent::Bind,
+          std::move(aEndpoint));
+    CanvasPlaybackLoop()->PostTask(runnable.forget());
+  }
+  return do_AddRef(canvasParent);
+}
+
+/* static */ bool
+CanvasParent::IsInCanvasThread()
+{
+  return (sCanvasWorkers && sCanvasWorkers->IsOnCurrentThread()) ||
+         (sCanvasThread &&
+          sCanvasThread->thread_id() == PlatformThread::CurrentId());
+}
+
+static already_AddRefed<nsIThreadPool>
+GetCanvasWorkers()
+{
+  if (!sCanvasWorkers && !sShuttingDown) {
+    // Given that the canvas workers are receiving instructions from content
+    // processes, it probably doesn't make sense to have more than half the
+    // number of processors doing canvas drawing. We set the lower limit to 2,
+    // so that even on single processor systems, if there is more than one
+    // window with canvas drawing, the OS can manage the load between them.
+    uint32_t threadLimit = std::max(2, PR_GetNumberOfProcessors() / 2);
+    sCanvasWorkers = SharedThreadPool::Get(NS_LITERAL_CSTRING("CanvasWorkers"),
+                                           threadLimit);
+  }
+
+  return do_AddRef(sCanvasWorkers);
+}
+
+/* static */ void
+CanvasParent::Shutdown()
+{
+  sShuttingDown = true;
+
+  if (sCanvasThread) {
+    sCanvasThread->Stop();
+    delete sCanvasThread;
+    sCanvasThread = nullptr;
+  }
+
+  if (sCanvasWorkers) {
+    sCanvasWorkers->Shutdown();
+    sCanvasWorkers = nullptr;
+  }
+}
+
+CanvasParent::CanvasParent() {}
+
+CanvasParent::~CanvasParent() {}
+
+void
+CanvasParent::Bind(Endpoint<PCanvasParent>&& aEndpoint)
+{
+  if (!aEndpoint.Bind(this)) {
+    return;
+  }
+
+  mSelfRef = this;
+}
+
+mozilla::ipc::IPCResult
+CanvasParent::RecvCreateTranslator(
+  const TextureType& aTextureType,
+  const ipc::SharedMemoryBasic::Handle& aReadHandle,
+  const CrossProcessSemaphoreHandle& aReaderSem,
+  const CrossProcessSemaphoreHandle& aWriterSem)
+{
+  mTranslator = CanvasTranslator::Create(aTextureType, aReadHandle, aReaderSem,
+                                         aWriterSem);
+  return RecvStartTranslation();
+}
+
+ipc::IPCResult
+CanvasParent::RecvStartTranslation()
+{
+  MOZ_ASSERT(mTranslator);
+
+  if (!mTranslator->IsValid()) {
+    return IPC_FAIL(this, "Canvas Translation failed.");
+  }
+
+  PostStartTranslationTask(nsIThread::DISPATCH_NORMAL);
+
+  return IPC_OK();
+}
+
+void
+CanvasParent::PostStartTranslationTask(uint32_t aDispatchFlags)
+{
+  if (sShuttingDown) {
+    return;
+  }
+
+  RefPtr<nsIThreadPool> canvasWorkers = GetCanvasWorkers();
+  RefPtr<Runnable> runnable =
+    NewRunnableMethod(
+      "CanvasParent::StartTranslation",
+      this,
+      &CanvasParent::StartTranslation);
+  canvasWorkers->Dispatch(runnable.forget(), aDispatchFlags);
+}
+
+void
+CanvasParent::StartTranslation()
+{
+  if (!mTranslator->TranslateRecording()) {
+    PostStartTranslationTask(nsIThread::DISPATCH_AT_END);
+  }
+}
+
+TextureData*
+CanvasParent::LookupTextureDataForClientDrawTarget(const uintptr_t aDrawTarget)
+{
+  return mTranslator->WaitForTextureData((void *)aDrawTarget);
+}
+
+void
+CanvasParent::DeallocPCanvasParent()
+{
+  mSelfRef = nullptr;
+}
+
+} // namespace layers
+} // namespace mozilla
diff --git a/gfx/layers/ipc/CanvasParent.h b/gfx/layers/ipc/CanvasParent.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/CanvasParent.h
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_layers_CanvasParent_h
+#define mozilla_layers_CanvasParent_h
+
+#include "mozilla/ipc/CrossProcessSemaphore.h"
+#include "mozilla/layers/CanvasTranslator.h"
+#include "mozilla/layers/PCanvasParent.h"
+#include "mozilla/UniquePtr.h"
+
+namespace mozilla {
+namespace layers {
+class TextureData;
+
+class CanvasParent final : public PCanvasParent
+{
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(CanvasParent)
+
+  friend class PProtocolParent;
+
+  /**
+   * Create a CanvasParent and bind it to the given endpoint on the
+   * CanvasPlaybackLoop.
+   *
+   * @params aEndpoint the endpoint to bind to
+   * @returns the new CanvasParent
+   */
+  static already_AddRefed<CanvasParent>
+    Create(Endpoint<PCanvasParent>&& aEndpoint);
+
+  static bool IsInCanvasThread();
+
+  /**
+   * Shutdown the canvas thread.
+   */
+  static void Shutdown();
+
+  /**
+   * Create a canvas translator for a particular TextureType, which translates
+   * events from a CanvasEventRingBuffer.
+   *
+   * @param aTextureType the TextureType the translator will create
+   * @param aReadHandle handle to the shared memory for the CanvasEventRingBuffer
+   * @param aReaderSem reading blocked semaphore for the CanvasEventRingBuffer
+   * @param aWriterSem writing blocked semaphore for the CanvasEventRingBuffer
+   */
+  ipc::IPCResult
+    RecvCreateTranslator(const TextureType& aTextureType,
+                         const ipc::SharedMemoryBasic::Handle& aReadHandle,
+                         const CrossProcessSemaphoreHandle& aReaderSem,
+                         const CrossProcessSemaphoreHandle& aWriterSem);
+
+  ipc::IPCResult RecvStartTranslation();
+
+  void ActorDestroy(ActorDestroyReason why) final {}
+
+  void DeallocPCanvasParent() final;
+
+  /**
+   * Used by the compositor thread to get the TextureData associated with the
+   * DrawTarget from another process.
+   *
+   * @param aDrawTarget the key to find the TextureData
+   * @returns the found TextureData
+   */
+  TextureData* LookupTextureDataForClientDrawTarget(const uintptr_t aDrawTarget);
+
+private:
+  CanvasParent();
+  ~CanvasParent() final;
+
+  DISALLOW_COPY_AND_ASSIGN(CanvasParent);
+
+  void Bind(Endpoint<PCanvasParent>&& aEndpoint);
+
+  void PostStartTranslationTask(uint32_t aDispatchFlags);
+
+  void StartTranslation();
+
+  RefPtr<CanvasParent> mSelfRef;
+  UniquePtr<CanvasTranslator> mTranslator;
+};
+
+} // namespace layers
+} // namespace mozilla
+
+#endif // mozilla_layers_CanvasParent_h
diff --git a/gfx/layers/ipc/CompositorBridgeChild.cpp b/gfx/layers/ipc/CompositorBridgeChild.cpp
--- a/gfx/layers/ipc/CompositorBridgeChild.cpp
+++ b/gfx/layers/ipc/CompositorBridgeChild.cpp
@@ -13,16 +13,17 @@
 #include "base/task.h"           // for NewRunnableMethod, etc
 #include "gfxPrefs.h"
 #include "mozilla/dom/TabGroup.h"
 #include "mozilla/layers/CompositorManagerChild.h"
 #include "mozilla/layers/ImageBridgeChild.h"
 #include "mozilla/layers/APZChild.h"
 #include "mozilla/layers/IAPZCTreeManager.h"
 #include "mozilla/layers/APZCTreeManagerChild.h"
+#include "mozilla/layers/CanvasChild.h"
 #include "mozilla/layers/LayerTransactionChild.h"
 #include "mozilla/layers/PaintThread.h"
 #include "mozilla/layers/PLayerTransactionChild.h"
 #include "mozilla/layers/PTextureChild.h"
 #include "mozilla/layers/TextureClient.h"      // for TextureClient
 #include "mozilla/layers/TextureClientPool.h"  // for TextureClientPool
 #include "mozilla/layers/WebRenderBridgeChild.h"
 #include "mozilla/layers/SyncObject.h"  // for SyncObjectClient
@@ -113,16 +114,20 @@ void CompositorBridgeChild::AfterDestroy
   // false to prevent normal IPDL calls from being made after SendWillClose.
   // The only time we should not issue Send__delete__ is if the actor is already
   // destroyed, e.g. the compositor process crashed.
   if (!mActorDestroyed) {
     Send__delete__(this);
     mActorDestroyed = true;
   }
 
+  if (mCanvasChild) {
+    mCanvasChild->Destroy();
+  }
+
   if (sCompositorBridge == this) {
     sCompositorBridge = nullptr;
   }
 }
 
 void CompositorBridgeChild::Destroy() {
   // This must not be called from the destructor!
   mTexturesWaitingRecycled.clear();
@@ -232,16 +237,28 @@ void CompositorBridgeChild::InitForConte
     // meaning mCanSend is still true. In this case we will try to send a
     // synchronous WillClose message to the parent, and will certainly get
     // a false result and a MsgDropped processing error. This is okay.
     old->Destroy();
   }
 
   mCanSend = true;
   mIdNamespace = aNamespace;
+
+  if (gfx::gfxVars::RemoteCanvasEnabled()) {
+    ipc::Endpoint<PCanvasParent> parentEndpoint;
+    ipc::Endpoint<PCanvasChild> childEndpoint;
+    nsresult rv = PCanvas::CreateEndpoints(OtherPid(), base::GetCurrentProcId(),
+                                           &parentEndpoint, &childEndpoint);
+    if (NS_SUCCEEDED(rv)) {
+      Unused << SendInitPCanvasParent(std::move(parentEndpoint));
+      mCanvasChild = new CanvasChild(std::move(childEndpoint));
+    }
+  }
+
   sCompositorBridge = this;
 }
 
 void CompositorBridgeChild::InitForWidget(uint64_t aProcessToken,
                                           LayerManager* aLayerManager,
                                           uint32_t aNamespace) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aProcessToken);
@@ -906,16 +923,26 @@ PTextureChild* CompositorBridgeChild::Cr
     SetEventTargetForActor(textureChild, aTarget);
   }
 
   return SendPTextureConstructor(
       textureChild, aSharedData, aReadLock, aLayersBackend, aFlags,
       LayersId{0} /* FIXME? */, aSerial, aExternalImageId);
 }
 
+already_AddRefed<CanvasChild> CompositorBridgeChild::GetCanvasChild() {
+  return do_AddRef(mCanvasChild);
+}
+
+void CompositorBridgeChild::EndCanvasTransaction() {
+  if (mCanvasChild) {
+    mCanvasChild->EndTransaction();
+  }
+}
+
 bool CompositorBridgeChild::AllocUnsafeShmem(
     size_t aSize, ipc::SharedMemory::SharedMemoryType aType,
     ipc::Shmem* aShmem) {
   ShmemAllocated(this);
   return PCompositorBridgeChild::AllocUnsafeShmem(aSize, aType, aShmem);
 }
 
 bool CompositorBridgeChild::AllocShmem(
diff --git a/gfx/layers/ipc/CompositorBridgeChild.h b/gfx/layers/ipc/CompositorBridgeChild.h
--- a/gfx/layers/ipc/CompositorBridgeChild.h
+++ b/gfx/layers/ipc/CompositorBridgeChild.h
@@ -36,16 +36,17 @@ class CompositorWidget;
 }  // namespace widget
 
 namespace layers {
 
 using mozilla::dom::TabChild;
 
 class IAPZCTreeManager;
 class APZCTreeManagerChild;
+class CanvasChild;
 class ClientLayerManager;
 class CompositorBridgeParent;
 class CompositorManagerChild;
 class CompositorOptions;
 class TextureClient;
 class TextureClientPool;
 struct FrameMetrics;
 
@@ -116,16 +117,20 @@ class CompositorBridgeChild final : publ
   mozilla::ipc::IPCResult RecvParentAsyncMessages(
       InfallibleTArray<AsyncParentMessageData>&& aMessages);
   virtual PTextureChild* CreateTexture(
       const SurfaceDescriptor& aSharedData, const ReadLockDescriptor& aReadLock,
       LayersBackend aLayersBackend, TextureFlags aFlags, uint64_t aSerial,
       wr::MaybeExternalImageId& aExternalImageId,
       nsIEventTarget* aTarget) override;
 
+  already_AddRefed<CanvasChild> GetCanvasChild() final;
+
+  void EndCanvasTransaction();
+
   /**
    * Request that the parent tell us when graphics are ready on GPU.
    * When we get that message, we bounce it to the TabParent via
    * the TabChild
    * @param tabChild The object to bounce the note to.  Non-NULL.
    */
   void RequestNotifyAfterRemotePaint(TabChild* aTabChild);
 
@@ -387,14 +392,16 @@ class CompositorBridgeChild final : publ
 
   // True if this CompositorBridge is currently delaying its messages until the
   // paint thread completes. This is R/W on both the main and paint threads, and
   // must be accessed within the paint lock.
   bool mIsDelayingForAsyncPaints;
 
   uintptr_t mSlowFlushCount;
   uintptr_t mTotalFlushCount;
+
+  RefPtr<CanvasChild> mCanvasChild;
 };
 
 }  // namespace layers
 }  // namespace mozilla
 
 #endif  // mozilla_layers_CompositorBrigedChild_h
diff --git a/gfx/layers/ipc/CompositorBridgeParent.cpp b/gfx/layers/ipc/CompositorBridgeParent.cpp
--- a/gfx/layers/ipc/CompositorBridgeParent.cpp
+++ b/gfx/layers/ipc/CompositorBridgeParent.cpp
@@ -2224,16 +2224,21 @@ PTextureParent* CompositorBridgeParent::
                                       aLayersBackend, aFlags, aSerial,
                                       aExternalImageId);
 }
 
 bool CompositorBridgeParent::DeallocPTextureParent(PTextureParent* actor) {
   return TextureHost::DestroyIPDLActor(actor);
 }
 
+mozilla::ipc::IPCResult CompositorBridgeParent::RecvInitPCanvasParent(
+    Endpoint<PCanvasParent>&& aEndpoint) {
+  MOZ_CRASH("PCanvasParent shouldn't be created via CompositorBridgeParent.");
+}
+
 bool CompositorBridgeParent::IsSameProcess() const {
   return OtherPid() == base::GetCurrentProcId();
 }
 
 void CompositorBridgeParent::NotifyWebRenderError(wr::WebRenderError aError) {
   MOZ_ASSERT(CompositorLoop() == MessageLoop::current());
   Unused << SendNotifyWebRenderError(aError);
 }
diff --git a/gfx/layers/ipc/CompositorBridgeParent.h b/gfx/layers/ipc/CompositorBridgeParent.h
--- a/gfx/layers/ipc/CompositorBridgeParent.h
+++ b/gfx/layers/ipc/CompositorBridgeParent.h
@@ -79,16 +79,17 @@ class CompositorManagerParent;
 class CompositorVsyncScheduler;
 class HostLayerManager;
 class IAPZCTreeManager;
 class LayerTransactionParent;
 class PAPZParent;
 class CrossProcessCompositorBridgeParent;
 class CompositorThreadHolder;
 class InProcessCompositorSession;
+class TextureData;
 class WebRenderBridgeParent;
 
 struct ScopedLayerTreeRegistration {
   ScopedLayerTreeRegistration(APZCTreeManager* aApzctm, LayersId aLayersId,
                               Layer* aRoot,
                               GeckoContentController* aController);
   ~ScopedLayerTreeRegistration();
 
@@ -183,16 +184,21 @@ class CompositorBridgeParentBase : publi
   bool StartSharingMetrics(mozilla::ipc::SharedMemoryBasic::Handle aHandle,
                            CrossProcessMutexHandle aMutexHandle,
                            LayersId aLayersId, uint32_t aApzcId) override;
   bool StopSharingMetrics(ScrollableLayerGuid::ViewID aScrollId,
                           uint32_t aApzcId) override;
 
   virtual bool IsRemote() const { return false; }
 
+  virtual TextureData* LookupTextureDataForClientDrawTarget(
+      const uintptr_t aDrawTarget) {
+    MOZ_CRASH("Should only be called on CrossProcessCompositorBridgeParent.");
+  }
+
   virtual void ForceComposeToTarget(gfx::DrawTarget* aTarget,
                                     const gfx::IntRect* aRect = nullptr) {
     MOZ_CRASH();
   }
 
   virtual void NotifyMemoryPressure() {}
   virtual void AccumulateMemoryReport(wr::MemoryReport*) {}
 
@@ -233,16 +239,18 @@ class CompositorBridgeParentBase : publi
   virtual mozilla::ipc::IPCResult RecvRemotePluginsReady() = 0;
   virtual mozilla::ipc::IPCResult RecvAdoptChild(const LayersId& id) = 0;
   virtual mozilla::ipc::IPCResult RecvFlushRenderingAsync() = 0;
   virtual mozilla::ipc::IPCResult RecvForcePresent() = 0;
   virtual mozilla::ipc::IPCResult RecvNotifyRegionInvalidated(
       const nsIntRegion& region) = 0;
   virtual mozilla::ipc::IPCResult RecvRequestNotifyAfterRemotePaint() = 0;
   virtual mozilla::ipc::IPCResult RecvAllPluginsCaptured() = 0;
+  virtual mozilla::ipc::IPCResult RecvInitPCanvasParent(
+      Endpoint<PCanvasParent>&& aEndpoint) = 0;
   virtual mozilla::ipc::IPCResult RecvInitialize(
       const LayersId& rootLayerTreeId) = 0;
   virtual mozilla::ipc::IPCResult RecvGetFrameUniformity(
       FrameUniformityData* data) = 0;
   virtual mozilla::ipc::IPCResult RecvWillClose() = 0;
   virtual mozilla::ipc::IPCResult RecvPause() = 0;
   virtual mozilla::ipc::IPCResult RecvResume() = 0;
   virtual mozilla::ipc::IPCResult RecvNotifyChildCreated(
@@ -377,16 +385,19 @@ class CompositorBridgeParent final : pub
 
   PTextureParent* AllocPTextureParent(
       const SurfaceDescriptor& aSharedData, const ReadLockDescriptor& aReadLock,
       const LayersBackend& aLayersBackend, const TextureFlags& aFlags,
       const LayersId& aId, const uint64_t& aSerial,
       const wr::MaybeExternalImageId& aExternalImageId) override;
   bool DeallocPTextureParent(PTextureParent* actor) override;
 
+  mozilla::ipc::IPCResult RecvInitPCanvasParent(
+      Endpoint<PCanvasParent>&& aEndpoint) final;
+
   bool IsSameProcess() const override;
 
   void NotifyWebRenderError(wr::WebRenderError aError);
   void NotifyWebRenderContextPurge();
   void NotifyPipelineRendered(const wr::PipelineId& aPipelineId,
                               const wr::Epoch& aEpoch,
                               const VsyncId& aCompositeStartId,
                               TimeStamp& aCompositeStart,
diff --git a/gfx/layers/ipc/CompositorThread.cpp b/gfx/layers/ipc/CompositorThread.cpp
--- a/gfx/layers/ipc/CompositorThread.cpp
+++ b/gfx/layers/ipc/CompositorThread.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #include "CompositorThread.h"
 #include "MainThreadUtils.h"
 #include "nsThreadUtils.h"
 #include "CompositorBridgeParent.h"
+#include "mozilla/layers/CanvasParent.h"
 #include "mozilla/layers/CompositorManagerParent.h"
 #include "mozilla/layers/ImageBridgeParent.h"
 #include "mozilla/media/MediaSystemResourceService.h"
 
 namespace mozilla {
 
 namespace gfx {
 // See VRManagerChild.cpp
@@ -124,16 +125,17 @@ void CompositorThreadHolder::Shutdown() 
     // We've already shutdown or never started.
     return;
   }
 
   ImageBridgeParent::Shutdown();
   gfx::ReleaseVRManagerParentSingleton();
   MediaSystemResourceService::Shutdown();
   CompositorManagerParent::Shutdown();
+  CanvasParent::Shutdown();
 
   sCompositorThreadHolder = nullptr;
 
   // No locking is needed around sFinishedCompositorShutDown because it is only
   // ever accessed on the main thread.
   SpinEventLoopUntil([&]() { return sFinishedCompositorShutDown; });
 
   CompositorBridgeParent::FinishShutdown();
diff --git a/gfx/layers/ipc/CrossProcessCompositorBridgeParent.cpp b/gfx/layers/ipc/CrossProcessCompositorBridgeParent.cpp
--- a/gfx/layers/ipc/CrossProcessCompositorBridgeParent.cpp
+++ b/gfx/layers/ipc/CrossProcessCompositorBridgeParent.cpp
@@ -16,16 +16,17 @@
 #ifdef XP_WIN
 #  include "mozilla/gfx/DeviceManagerDx.h"  // for DeviceManagerDx
 #endif
 #include "mozilla/ipc/Transport.h"           // for Transport
 #include "mozilla/layers/AnimationHelper.h"  // for CompositorAnimationStorage
 #include "mozilla/layers/APZCTreeManagerParent.h"  // for APZCTreeManagerParent
 #include "mozilla/layers/APZUpdater.h"             // for APZUpdater
 #include "mozilla/layers/AsyncCompositionManager.h"
+#include "mozilla/layers/CanvasParent.h"
 #include "mozilla/layers/CompositorOptions.h"
 #include "mozilla/layers/CompositorThread.h"
 #include "mozilla/layers/LayerManagerComposite.h"
 #include "mozilla/layers/LayerTreeOwnerTracker.h"
 #include "mozilla/layers/PLayerTransactionParent.h"
 #include "mozilla/layers/RemoteContentController.h"
 #include "mozilla/layers/WebRenderBridgeParent.h"
 #include "mozilla/layers/AsyncImagePipelineManager.h"
@@ -610,16 +611,33 @@ PTextureParent* CrossProcessCompositorBr
                                       aExternalImageId);
 }
 
 bool CrossProcessCompositorBridgeParent::DeallocPTextureParent(
     PTextureParent* actor) {
   return TextureHost::DestroyIPDLActor(actor);
 }
 
+mozilla::ipc::IPCResult
+CrossProcessCompositorBridgeParent::RecvInitPCanvasParent(
+    Endpoint<PCanvasParent>&& aEndpoint) {
+  MOZ_RELEASE_ASSERT(!mCanvasParent,
+                     "Canvas Parent should only be created once per "
+                     "CrossProcessCompositorBridgeParent.");
+
+  mCanvasParent = CanvasParent::Create(std::move(aEndpoint));
+  return IPC_OK();
+}
+
+TextureData*
+CrossProcessCompositorBridgeParent::LookupTextureDataForClientDrawTarget(
+    const uintptr_t aDrawTarget) {
+  return mCanvasParent->LookupTextureDataForClientDrawTarget(aDrawTarget);
+}
+
 bool CrossProcessCompositorBridgeParent::IsSameProcess() const {
   return OtherPid() == base::GetCurrentProcId();
 }
 
 void CrossProcessCompositorBridgeParent::UpdatePaintTime(
     LayerTransactionParent* aLayerTree, const TimeDuration& aPaintTime) {
   LayersId id = aLayerTree->GetId();
   MOZ_ASSERT(id.IsValid());
diff --git a/gfx/layers/ipc/CrossProcessCompositorBridgeParent.h b/gfx/layers/ipc/CrossProcessCompositorBridgeParent.h
--- a/gfx/layers/ipc/CrossProcessCompositorBridgeParent.h
+++ b/gfx/layers/ipc/CrossProcessCompositorBridgeParent.h
@@ -4,20 +4,22 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_layers_CrossProcessCompositorBridgeParent_h
 #define mozilla_layers_CrossProcessCompositorBridgeParent_h
 
 #include "mozilla/layers/CompositorBridgeParent.h"
 #include "mozilla/layers/CompositorThread.h"
+#include "mozilla/UniquePtr.h"
 
 namespace mozilla {
 namespace layers {
 
+class CanvasParent;
 class CompositorOptions;
 
 /**
  * This class handles layer updates pushed directly from child processes to
  * the compositor thread. It's associated with a CompositorBridgeParent on the
  * compositor thread. While it uses the PCompositorBridge protocol to manage
  * these updates, it doesn't actually drive compositing itself. For that it
  * hands off work to the CompositorBridgeParent it's associated with.
@@ -143,16 +145,19 @@ class CrossProcessCompositorBridgeParent
   PTextureParent* AllocPTextureParent(
       const SurfaceDescriptor& aSharedData, const ReadLockDescriptor& aReadLock,
       const LayersBackend& aLayersBackend, const TextureFlags& aFlags,
       const LayersId& aId, const uint64_t& aSerial,
       const wr::MaybeExternalImageId& aExternalImageId) override;
 
   bool DeallocPTextureParent(PTextureParent* actor) override;
 
+  mozilla::ipc::IPCResult RecvInitPCanvasParent(
+      Endpoint<PCanvasParent>&& aEndpoint) final;
+
   bool IsSameProcess() const override;
 
   PCompositorWidgetParent* AllocPCompositorWidgetParent(
       const CompositorWidgetInitData& aInitData) override {
     // Not allowed.
     return nullptr;
   }
   bool DeallocPCompositorWidgetParent(
@@ -179,29 +184,34 @@ class CrossProcessCompositorBridgeParent
       const LayoutDeviceIntSize& aSize) override;
   bool DeallocPWebRenderBridgeParent(PWebRenderBridgeParent* aActor) override;
 
   void ObserveLayersUpdate(LayersId aLayersId, LayersObserverEpoch aEpoch,
                            bool aActive) override;
 
   bool IsRemote() const override { return true; }
 
+  TextureData* LookupTextureDataForClientDrawTarget(
+      const uintptr_t aDrawTarget) final;
+
  private:
   // Private destructor, to discourage deletion outside of Release():
   virtual ~CrossProcessCompositorBridgeParent();
 
   void DeferredDestroy();
 
   // There can be many CPCPs, and IPDL-generated code doesn't hold a
   // reference to top-level actors.  So we hold a reference to
   // ourself.  This is released (deferred) in ActorDestroy().
   RefPtr<CrossProcessCompositorBridgeParent> mSelfRef;
 
   // If true, we should send a RemotePaintIsReady message when the layer
   // transaction is received
   bool mNotifyAfterRemotePaint;
   bool mDestroyCalled;
+
+  RefPtr<CanvasParent> mCanvasParent;
 };
 
 }  // namespace layers
 }  // namespace mozilla
 
 #endif  // mozilla_layers_CrossProcessCompositorBridgeParent_h
diff --git a/gfx/layers/ipc/LayersMessageUtils.h b/gfx/layers/ipc/LayersMessageUtils.h
--- a/gfx/layers/ipc/LayersMessageUtils.h
+++ b/gfx/layers/ipc/LayersMessageUtils.h
@@ -69,16 +69,22 @@ struct ParamTraits<mozilla::layers::Laye
 template <>
 struct ParamTraits<mozilla::layers::LayersBackend>
     : public ContiguousEnumSerializer<
           mozilla::layers::LayersBackend,
           mozilla::layers::LayersBackend::LAYERS_NONE,
           mozilla::layers::LayersBackend::LAYERS_LAST> {};
 
 template <>
+struct ParamTraits<mozilla::layers::TextureType>
+    : public ContiguousEnumSerializer<mozilla::layers::TextureType,
+                                      mozilla::layers::TextureType::Unknown,
+                                      mozilla::layers::TextureType::Last> {};
+
+template <>
 struct ParamTraits<mozilla::layers::ScaleMode>
     : public ContiguousEnumSerializerInclusive<
           mozilla::layers::ScaleMode, mozilla::layers::ScaleMode::SCALE_NONE,
           mozilla::layers::kHighestScaleMode> {};
 
 template <>
 struct ParamTraits<mozilla::StyleScrollSnapType>
     : public ContiguousEnumSerializerInclusive<
diff --git a/gfx/layers/ipc/LayersSurfaces.ipdlh b/gfx/layers/ipc/LayersSurfaces.ipdlh
--- a/gfx/layers/ipc/LayersSurfaces.ipdlh
+++ b/gfx/layers/ipc/LayersSurfaces.ipdlh
@@ -136,25 +136,30 @@ struct SurfaceDescriptorBuffer {
 struct SurfaceDescriptorShared
 {
   IntSize size;
   int32_t stride;
   SurfaceFormat format;
   Handle handle;
 };
 
+struct SurfaceDescriptorRecorded {
+  uintptr_t drawTarget;
+};
+
 union SurfaceDescriptor {
   SurfaceDescriptorBuffer;
   SurfaceDescriptorDIB;
   SurfaceDescriptorD3D10;
   SurfaceDescriptorFileMapping;
   SurfaceDescriptorDXGIYCbCr;
   SurfaceDescriptorX11;
   SurfaceTextureDescriptor;
   EGLImageDescriptor;
   SurfaceDescriptorMacIOSurface;
   SurfaceDescriptorSharedGLTexture;
   SurfaceDescriptorGPUVideo;
+  SurfaceDescriptorRecorded;
   null_t;
 };
 
 } // namespace
 } // namespace
diff --git a/gfx/layers/ipc/PCanvas.ipdl b/gfx/layers/ipc/PCanvas.ipdl
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/PCanvas.ipdl
@@ -0,0 +1,27 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=8 et : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+using mozilla::CrossProcessSemaphoreHandle from "mozilla/ipc/CrossProcessSemaphore.h";
+using mozilla::layers::TextureType from "mozilla/layers/LayersTypes.h";
+using mozilla::ipc::SharedMemoryBasic::Handle from "mozilla/ipc/SharedMemoryBasic.h";
+
+namespace mozilla {
+namespace layers {
+
+/**
+ * PCanvas is the IPDL for recorded Canvas drawing.
+ */
+sync protocol PCanvas {
+parent:
+  async CreateTranslator(TextureType aTextureType, Handle aReadHandle,
+                         CrossProcessSemaphoreHandle aReaderSem,
+                         CrossProcessSemaphoreHandle aWriterSem);
+
+  async StartTranslation();
+};
+
+} // layers
+} // mozilla
diff --git a/gfx/layers/ipc/PCompositorBridge.ipdl b/gfx/layers/ipc/PCompositorBridge.ipdl
--- a/gfx/layers/ipc/PCompositorBridge.ipdl
+++ b/gfx/layers/ipc/PCompositorBridge.ipdl
@@ -6,16 +6,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include LayersSurfaces;
 include LayersMessages;
 include PlatformWidgetTypes;
 include protocol PAPZ;
 include protocol PAPZCTreeManager;
 include protocol PBrowser;
+include protocol PCanvas;
 include protocol PCompositorManager;
 include protocol PCompositorWidget;
 include protocol PLayerTransaction;
 include protocol PTexture;
 include protocol PWebRenderBridge;
 include "mozilla/GfxMessageUtils.h";
 include "mozilla/layers/LayersMessageUtils.h";
 include "mozilla/layers/WebRenderMessageUtils.h";
@@ -251,16 +252,18 @@ parent:
 
   /**
    * Sent when the child has finished CaptureAllPlugins.
    */
   async AllPluginsCaptured();
 
   async PTexture(SurfaceDescriptor aSharedData, ReadLockDescriptor aReadLock, LayersBackend aBackend, TextureFlags aTextureFlags, LayersId id, uint64_t aSerial, MaybeExternalImageId aExternalImageId);
 
+  async InitPCanvasParent(Endpoint<PCanvasParent> aEndpoint);
+
   sync SyncWithCompositor();
 
   // The pipelineId is the same as the layersId
   async PWebRenderBridge(PipelineId pipelineId, LayoutDeviceIntSize aSize);
 
   sync CheckContentOnlyTDR(uint32_t sequenceNum)
     returns (bool isContentOnlyTDR);
 
diff --git a/gfx/layers/ipc/TextureForwarder.h b/gfx/layers/ipc/TextureForwarder.h
--- a/gfx/layers/ipc/TextureForwarder.h
+++ b/gfx/layers/ipc/TextureForwarder.h
@@ -14,16 +14,17 @@
 #include "mozilla/layers/TextureClient.h"   // for TextureClient
 #include "mozilla/layers/KnowsCompositor.h"
 
 namespace mozilla {
 namespace ipc {
 class IShmemAllocator;
 }
 namespace layers {
+class CanvasChild;
 
 /**
  * An abstract interface for classes that implement the autogenerated
  * IPDL actor class. Lets us check if they are still valid for IPC.
  */
 class LayersIPCActor {
  public:
   virtual bool IPCOpen() const { return true; }
@@ -73,14 +74,19 @@ class TextureForwarder : public LayersIP
    * Create a TextureChild/Parent pair as as well as the TextureHost on the
    * parent side.
    */
   virtual PTextureChild* CreateTexture(
       const SurfaceDescriptor& aSharedData, const ReadLockDescriptor& aReadLock,
       LayersBackend aLayersBackend, TextureFlags aFlags, uint64_t aSerial,
       wr::MaybeExternalImageId& aExternalImageId,
       nsIEventTarget* aTarget = nullptr) = 0;
+
+  /**
+   * Returns the CanvasChild for this TextureForwarder.
+   */
+  virtual already_AddRefed<CanvasChild> GetCanvasChild() { return nullptr; };
 };
 
 }  // namespace layers
 }  // namespace mozilla
 
 #endif
diff --git a/gfx/layers/moz.build b/gfx/layers/moz.build
--- a/gfx/layers/moz.build
+++ b/gfx/layers/moz.build
@@ -121,28 +121,31 @@ EXPORTS.mozilla.layers += [
     'AtomicRefCountedWithFinalize.h',
     'AxisPhysicsModel.h',
     'AxisPhysicsMSDModel.h',
     'basic/BasicCompositor.h',
     'basic/MacIOSurfaceTextureHostBasic.h',
     'basic/TextureHostBasic.h',
     'BSPTree.h',
     'BufferTexture.h',
+    'CanvasDrawEventRecorder.h',
     'CanvasRenderer.h',
+    'CanvasTranslator.h',
     'client/CanvasClient.h',
     'client/CompositableClient.h',
     'client/ContentClient.h',
     'client/GPUVideoTextureClient.h',
     'client/ImageClient.h',
     'client/MultiTiledContentClient.h',
     'client/SingleTiledContentClient.h',
     'client/TextureClient.h',
     'client/TextureClientPool.h',
     'client/TextureClientRecycleAllocator.h',
     'client/TextureClientSharedSurface.h',
+    'client/TextureRecorded.h',
     'client/TiledContentClient.h',
     'composite/AsyncCompositionManager.h',
     'composite/CanvasLayerComposite.h',
     'composite/ColorLayerComposite.h',
     'composite/CompositorScreenshotGrabber.h',
     'composite/ContainerLayerComposite.h',
     'composite/ContentHost.h',
     'composite/Diagnostics.h',
@@ -166,16 +169,18 @@ EXPORTS.mozilla.layers += [
     'DirectionUtils.h',
     'Effects.h',
     'ImageDataSerializer.h',
     'ipc/APZChild.h',
     'ipc/APZCTreeManagerChild.h',
     'ipc/APZCTreeManagerParent.h',
     'ipc/APZInputBridgeChild.h',
     'ipc/APZInputBridgeParent.h',
+    'ipc/CanvasChild.h',
+    'ipc/CanvasParent.h',
     'ipc/CompositableForwarder.h',
     'ipc/CompositableTransactionParent.h',
     'ipc/CompositorBridgeChild.h',
     'ipc/CompositorBridgeParent.h',
     'ipc/CompositorManagerChild.h',
     'ipc/CompositorManagerParent.h',
     'ipc/CompositorThread.h',
     'ipc/CompositorVsyncScheduler.h',
@@ -358,17 +363,19 @@ UNIFIED_SOURCES += [
     'basic/BasicContainerLayer.cpp',
     'basic/BasicImages.cpp',
     'basic/BasicLayerManager.cpp',
     'basic/BasicLayersImpl.cpp',
     'basic/BasicPaintedLayer.cpp',
     'basic/TextureHostBasic.cpp',
     'BSPTree.cpp',
     'BufferTexture.cpp',
+    'CanvasDrawEventRecorder.cpp',
     'CanvasRenderer.cpp',
+    'CanvasTranslator.cpp',
     'client/CanvasClient.cpp',
     'client/ClientCanvasLayer.cpp',
     'client/ClientCanvasRenderer.cpp',
     'client/ClientColorLayer.cpp',
     'client/ClientContainerLayer.cpp',
     'client/ClientImageLayer.cpp',
     'client/ClientLayerManager.cpp',
     'client/ClientPaintedLayer.cpp',
@@ -378,16 +385,17 @@ UNIFIED_SOURCES += [
     'client/GPUVideoTextureClient.cpp',
     'client/ImageClient.cpp',
     'client/MultiTiledContentClient.cpp',
     'client/SingleTiledContentClient.cpp',
     'client/TextureClient.cpp',
     'client/TextureClientPool.cpp',
     'client/TextureClientRecycleAllocator.cpp',
     'client/TextureClientSharedSurface.cpp',
+    'client/TextureRecorded.cpp',
     'client/TiledContentClient.cpp',
     'composite/AsyncCompositionManager.cpp',
     'composite/CanvasLayerComposite.cpp',
     'composite/ColorLayerComposite.cpp',
     'composite/CompositableHost.cpp',
     'composite/CompositorScreenshotGrabber.cpp',
     'composite/ContainerLayerComposite.cpp',
     'composite/ContentHost.cpp',
@@ -410,16 +418,18 @@ UNIFIED_SOURCES += [
     'GLImages.cpp',
     'ImageDataSerializer.cpp',
     'ImageLayers.cpp',
     'ipc/APZChild.cpp',
     'ipc/APZCTreeManagerChild.cpp',
     'ipc/APZCTreeManagerParent.cpp',
     'ipc/APZInputBridgeChild.cpp',
     'ipc/APZInputBridgeParent.cpp',
+    'ipc/CanvasChild.cpp',
+    'ipc/CanvasParent.cpp',
     'ipc/CompositableTransactionParent.cpp',
     'ipc/CompositorBench.cpp',
     'ipc/CompositorBridgeChild.cpp',
     'ipc/CompositorBridgeParent.cpp',
     'ipc/CompositorManagerChild.cpp',
     'ipc/CompositorManagerParent.cpp',
     'ipc/CompositorThread.cpp',
     'ipc/CompositorVsyncScheduler.cpp',
@@ -524,16 +534,17 @@ if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'coco
     ]
 
 IPDL_SOURCES += [
     'ipc/LayersMessages.ipdlh',
     'ipc/LayersSurfaces.ipdlh',
     'ipc/PAPZ.ipdl',
     'ipc/PAPZCTreeManager.ipdl',
     'ipc/PAPZInputBridge.ipdl',
+    'ipc/PCanvas.ipdl',
     'ipc/PCompositorBridge.ipdl',
     'ipc/PCompositorManager.ipdl',
     'ipc/PImageBridge.ipdl',
     'ipc/PLayerTransaction.ipdl',
     'ipc/PTexture.ipdl',
     'ipc/PUiCompositorController.ipdl',
     'ipc/PVideoBridge.ipdl',
     'ipc/PWebRenderBridge.ipdl',
diff --git a/gfx/layers/wr/WebRenderLayerManager.cpp b/gfx/layers/wr/WebRenderLayerManager.cpp
--- a/gfx/layers/wr/WebRenderLayerManager.cpp
+++ b/gfx/layers/wr/WebRenderLayerManager.cpp
@@ -216,16 +216,18 @@ bool WebRenderLayerManager::EndEmptyTran
   // device-reset status.
   if (!gfxPlatform::GetPlatform()->DidRenderingDeviceReset()) {
     if (WrBridge()->GetSyncObject() &&
         WrBridge()->GetSyncObject()->IsSyncObjectValid()) {
       WrBridge()->GetSyncObject()->Synchronize();
     }
   }
 
+  GetCompositorBridgeChild()->EndCanvasTransaction();
+
   Maybe<wr::IpcResourceUpdateQueue> nothing;
   WrBridge()->EndEmptyTransaction(mFocusTarget, mPendingScrollUpdates,
                                   mStateManager.mAsyncResourceUpdates,
                                   mPaintSequenceNumber, mLatestTransactionId,
                                   mTransactionIdAllocator->GetVsyncId(),
                                   mTransactionIdAllocator->GetVsyncStart(),
                                   refreshStart, mTransactionStart, mURL);
   ClearPendingScrollInfoUpdate();
@@ -342,16 +344,18 @@ void WebRenderLayerManager::EndTransacti
   // device-reset status.
   if (!gfxPlatform::GetPlatform()->DidRenderingDeviceReset()) {
     if (WrBridge()->GetSyncObject() &&
         WrBridge()->GetSyncObject()->IsSyncObjectValid()) {
       WrBridge()->GetSyncObject()->Synchronize();
     }
   }
 
+  GetCompositorBridgeChild()->EndCanvasTransaction();
+
   wr::BuiltDisplayList dl;
   builder.Finalize(contentSize, dl);
   mLastDisplayListSize = dl.dl.inner.capacity;
 
   {
     AUTO_PROFILER_TRACING("Paint", "ForwardDPTransaction", GRAPHICS);
     WrBridge()->EndTransaction(contentSize, dl, resourceUpdates,
                                size.ToUnknownSize(), mLatestTransactionId,
@@ -611,17 +615,19 @@ void WebRenderLayerManager::SetRoot(Laye
 
 already_AddRefed<PersistentBufferProvider>
 WebRenderLayerManager::CreatePersistentBufferProvider(
     const gfx::IntSize& aSize, gfx::SurfaceFormat aFormat) {
   // Ensure devices initialization for canvas 2d. The devices are lazily
   // initialized with WebRender to reduce memory usage.
   gfxPlatform::GetPlatform()->EnsureDevicesInitialized();
 
-  if (gfxPrefs::PersistentBufferProviderSharedEnabled()) {
+  LayersBackend backendType = AsKnowsCompositor()->GetCompositorBackendType();
+  if (gfxPrefs::PersistentBufferProviderSharedEnabled() ||
+      TextureData::IsRemote(backendType, BackendSelector::Canvas)) {
     RefPtr<PersistentBufferProvider> provider =
         PersistentBufferProviderShared::Create(aSize, aFormat,
                                                AsKnowsCompositor());
     if (provider) {
       return provider.forget();
     }
   }
   return LayerManager::CreatePersistentBufferProvider(aSize, aFormat);
diff --git a/gfx/thebes/DeviceManagerDx.cpp b/gfx/thebes/DeviceManagerDx.cpp
--- a/gfx/thebes/DeviceManagerDx.cpp
+++ b/gfx/thebes/DeviceManagerDx.cpp
@@ -259,16 +259,54 @@ bool DeviceManagerDx::CreateVRDevice() {
   if (FAILED(hr) || !mVRDevice) {
     NS_WARNING("Failed to acquire a D3D11 device for VR");
     return false;
   }
 
   return true;
 }
 
+bool DeviceManagerDx::CreateCanvasDevice() {
+  MOZ_ASSERT(ProcessOwnsCompositor());
+
+  if (mCanvasDevice) {
+    return true;
+  }
+
+  if (!LoadD3D11()) {
+    return false;
+  }
+
+  RefPtr<IDXGIAdapter1> adapter = GetDXGIAdapter();
+  if (!adapter) {
+    NS_WARNING("Failed to acquire a DXGI adapter for Canvas");
+    return false;
+  }
+
+  UINT flags = D3D11_CREATE_DEVICE_BGRA_SUPPORT;
+
+  HRESULT hr;
+  if (!CreateDevice(adapter, D3D_DRIVER_TYPE_UNKNOWN, flags, hr,
+                    mCanvasDevice)) {
+    gfxCriticalError() << "Crash during D3D11 device creation for Canvas";
+    return false;
+  }
+
+  if (FAILED(hr) || !mCanvasDevice) {
+    NS_WARNING("Failed to acquire a D3D11 device for Canvas");
+    return false;
+  }
+
+  if (XRE_IsGPUProcess()) {
+    Factory::SetDirect3D11Device(mCanvasDevice);
+  }
+
+  return true;
+}
+
 void DeviceManagerDx::CreateDirectCompositionDevice() {
   if (!gfxVars::UseWebRenderDCompWin()) {
     return;
   }
 
   if (!mCompositorDevice) {
     return;
   }
@@ -858,16 +896,17 @@ void DeviceManagerDx::ResetDevices() {
 
   MutexAutoLock lock(mDeviceLock);
 
   mAdapter = nullptr;
   mCompositorAttachments = nullptr;
   mMLGDevice = nullptr;
   mCompositorDevice = nullptr;
   mContentDevice = nullptr;
+  mCanvasDevice = nullptr;
   mImageDevice = nullptr;
   mDeviceStatus = Nothing();
   mDeviceResetReason = Nothing();
   Factory::SetDirect3D11Device(nullptr);
 }
 
 bool DeviceManagerDx::MaybeResetAndReacquireDevices() {
   DeviceResetReason resetReason;
@@ -880,26 +919,30 @@ bool DeviceManagerDx::MaybeResetAndReacq
                           uint32_t(resetReason));
   }
 
   CrashReporter::AnnotateCrashReport(
       CrashReporter::Annotation::DeviceResetReason, int(resetReason));
 
   bool createCompositorDevice = !!mCompositorDevice;
   bool createContentDevice = !!mContentDevice;
+  bool createCanvasDevice = !!mCanvasDevice;
 
   ResetDevices();
 
   if (createCompositorDevice && !CreateCompositorDevices()) {
     // Just stop, don't try anything more
     return true;
   }
   if (createContentDevice) {
     CreateContentDevices();
   }
+  if (createCanvasDevice) {
+    CreateCanvasDevice();
+  }
 
   return true;
 }
 
 bool DeviceManagerDx::ContentAdapterIsParentAdapter(ID3D11Device* device) {
   DXGI_ADAPTER_DESC desc;
   if (!D3D11Checks::GetDxgiDesc(device, &desc)) {
     gfxCriticalNote << "Could not query device DXGI adapter info";
@@ -977,16 +1020,17 @@ static inline bool DidDeviceReset(const 
   return true;
 }
 
 bool DeviceManagerDx::GetAnyDeviceRemovedReason(DeviceResetReason* aOutReason) {
   // Caller must own the lock, since we access devices directly, and can be
   // called from any thread.
   mDeviceLock.AssertCurrentThreadOwns();
 
+  // TODO: Do we need to add mCanvasDevice to this?
   if (DidDeviceReset(mCompositorDevice, aOutReason) ||
       DidDeviceReset(mContentDevice, aOutReason)) {
     return true;
   }
 
   if (XRE_IsParentProcess() && NS_IsMainThread() &&
       gfxPrefs::DeviceResetForTesting()) {
     gfxPrefs::SetDeviceResetForTesting(0);
@@ -1061,16 +1105,24 @@ RefPtr<ID3D11Device> DeviceManagerDx::Ge
 RefPtr<ID3D11Device> DeviceManagerDx::GetVRDevice() {
   MutexAutoLock lock(mDeviceLock);
   if (!mVRDevice) {
     CreateVRDevice();
   }
   return mVRDevice;
 }
 
+RefPtr<ID3D11Device> DeviceManagerDx::GetCanvasDevice() {
+  MutexAutoLock lock(mDeviceLock);
+  if (!mCanvasDevice) {
+    CreateCanvasDevice();
+  }
+  return mCanvasDevice;
+}
+
 RefPtr<IDCompositionDevice> DeviceManagerDx::GetDirectCompositionDevice() {
   MutexAutoLock lock(mDeviceLock);
   return mDirectCompositionDevice;
 }
 
 unsigned DeviceManagerDx::GetCompositorFeatureLevel() const {
   if (!mDeviceStatus) {
     return 0;
diff --git a/gfx/thebes/DeviceManagerDx.h b/gfx/thebes/DeviceManagerDx.h
--- a/gfx/thebes/DeviceManagerDx.h
+++ b/gfx/thebes/DeviceManagerDx.h
@@ -14,16 +14,17 @@
 #include "mozilla/StaticPtr.h"
 #include "mozilla/gfx/GraphicsMessages.h"
 #include "nsTArray.h"
 #include "nsWindowsHelpers.h"
 
 #include <windows.h>
 #include <objbase.h>
 
+#include <d3d11.h>
 #include <dxgi.h>
 #include <dxgi1_6.h>
 
 // This header is available in the June 2010 SDK and in the Win8 SDK
 #include <d3dcommon.h>
 // Win 8.0 SDK types we'll need when building using older sdks.
 #if !defined(D3D_FEATURE_LEVEL_11_1)  // defined in the 8.0 SDK only
 #  define D3D_FEATURE_LEVEL_11_1 static_cast<D3D_FEATURE_LEVEL>(0xb100)
@@ -51,16 +52,17 @@ class DeviceManagerDx final {
   static void Shutdown();
 
   DeviceManagerDx();
 
   static DeviceManagerDx* Get() { return sInstance; }
 
   RefPtr<ID3D11Device> GetCompositorDevice();
   RefPtr<ID3D11Device> GetContentDevice();
+  RefPtr<ID3D11Device> GetCanvasDevice();
   RefPtr<ID3D11Device> GetImageDevice();
   RefPtr<IDCompositionDevice> GetDirectCompositionDevice();
   RefPtr<ID3D11Device> GetVRDevice();
   RefPtr<ID3D11Device> CreateDecoderDevice();
   RefPtr<layers::MLGDevice> GetMLGDevice();
   IDirectDraw7* GetDirectDraw();
 
   unsigned GetCompositorFeatureLevel() const;
@@ -83,16 +85,17 @@ class DeviceManagerDx final {
   bool HasCrashyInitData();
 
   // Enumerate and return all outputs on the current adapter.
   nsTArray<DXGI_OUTPUT_DESC1> EnumerateOutputs();
 
   bool CreateCompositorDevices();
   void CreateContentDevices();
   void CreateDirectCompositionDevice();
+  bool CreateCanvasDevice();
 
   void GetCompositorDevices(
       RefPtr<ID3D11Device>* aOutDevice,
       RefPtr<layers::DeviceAttachmentsD3D11>* aOutAttachments);
 
   void ImportDeviceInfo(const D3D11DeviceStatus& aDeviceStatus);
   void ExportDeviceInfo(D3D11DeviceStatus* aOut);
 
@@ -160,16 +163,17 @@ class DeviceManagerDx final {
 
   nsModuleHandle mDcompModule;
 
   mozilla::Mutex mDeviceLock;
   nsTArray<D3D_FEATURE_LEVEL> mFeatureLevels;
   RefPtr<IDXGIAdapter1> mAdapter;
   RefPtr<ID3D11Device> mCompositorDevice;
   RefPtr<ID3D11Device> mContentDevice;
+  RefPtr<ID3D11Device> mCanvasDevice;
   RefPtr<ID3D11Device> mImageDevice;
   RefPtr<ID3D11Device> mVRDevice;
   RefPtr<ID3D11Device> mDecoderDevice;
   RefPtr<IDCompositionDevice> mDirectCompositionDevice;
 
   RefPtr<layers::DeviceAttachmentsD3D11> mCompositorAttachments;
   RefPtr<layers::MLGDevice> mMLGDevice;
   bool mCompositorDeviceSupportsVideo;
diff --git a/gfx/thebes/gfxPlatform.cpp b/gfx/thebes/gfxPlatform.cpp
--- a/gfx/thebes/gfxPlatform.cpp
+++ b/gfx/thebes/gfxPlatform.cpp
@@ -2483,16 +2483,19 @@ void gfxPlatform::InitAcceleration() {
 
   sLayersAccelerationPrefsInitialized = true;
 
   if (XRE_IsParentProcess()) {
     Preferences::RegisterCallbackAndCall(
         VideoDecodingFailedChangedCallback,
         "media.hardware-video-decoding.failed");
     InitGPUProcessPrefs();
+
+    gfxVars::SetRemoteCanvasEnabled(gfxPrefs::CanvasRemote() &&
+                                    gfxConfig::IsEnabled(Feature::GPU_PROCESS));
   }
 }
 
 void gfxPlatform::InitGPUProcessPrefs() {
   // We want to hide this from about:support, so only set a default if the
   // pref is known to be true.
   if (!gfxPrefs::GPUProcessEnabled() && !gfxPrefs::GPUProcessForceEnabled()) {
     return;
@@ -3278,16 +3281,18 @@ void gfxPlatform::NotifyCompositorCreate
 /* static */ void gfxPlatform::NotifyGPUProcessDisabled() {
   if (gfxConfig::IsEnabled(Feature::WEBRENDER)) {
     gfxConfig::GetFeature(Feature::WEBRENDER)
         .ForceDisable(
             FeatureStatus::Unavailable, "GPU Process is disabled",
             NS_LITERAL_CSTRING("FEATURE_FAILURE_GPU_PROCESS_DISABLED"));
     gfxVars::SetUseWebRender(false);
   }
+
+  gfxVars::SetRemoteCanvasEnabled(false);
 }
 
 void gfxPlatform::FetchAndImportContentDeviceData() {
   MOZ_ASSERT(XRE_IsContentProcess());
 
   if (gContentDeviceInitData) {
     ImportContentDeviceData(*gContentDeviceInitData);
     return;
diff --git a/gfx/thebes/gfxPrefs.h b/gfx/thebes/gfxPrefs.h
--- a/gfx/thebes/gfxPrefs.h
+++ b/gfx/thebes/gfxPrefs.h
@@ -470,16 +470,18 @@ class gfxPrefs final {
 #endif // defined(MOZ_WIDGET_ANDROID)
   DECL_GFX_PREF(Live, "gfx.compositor.clearstate",             CompositorClearState, bool, false);
   DECL_GFX_PREF(Live, "gfx.compositor.glcontext.opaque",       CompositorGLContextOpaque, bool, false);
   DECL_GFX_PREF(Live, "gfx.canvas.auto_accelerate.min_calls",  CanvasAutoAccelerateMinCalls, int32_t, 4);
   DECL_GFX_PREF(Live, "gfx.canvas.auto_accelerate.min_frames", CanvasAutoAccelerateMinFrames, int32_t, 30);
   DECL_GFX_PREF(Live, "gfx.canvas.auto_accelerate.min_seconds", CanvasAutoAccelerateMinSeconds, float, 5.0f);
   DECL_GFX_PREF(Live, "gfx.canvas.azure.accelerated",          CanvasAzureAccelerated, bool, false);
   DECL_GFX_PREF(Once, "gfx.canvas.azure.accelerated.limit",    CanvasAzureAcceleratedLimit, int32_t, 0);
+  DECL_GFX_PREF(Live, "gfx.canvas.remote",                     CanvasRemote, bool, false);
+
   // 0x7fff is the maximum supported xlib surface size and is more than enough for canvases.
   DECL_GFX_PREF(Live, "gfx.canvas.max-size",                   MaxCanvasSize, int32_t, 0x7fff);
   DECL_GFX_PREF(Once, "gfx.canvas.skiagl.cache-items",         CanvasSkiaGLCacheItems, int32_t, 256);
   DECL_GFX_PREF(Once, "gfx.canvas.skiagl.cache-size",          CanvasSkiaGLCacheSize, int32_t, 96);
   DECL_GFX_PREF(Once, "gfx.canvas.skiagl.dynamic-cache",       CanvasSkiaGLDynamicCache, bool, false);
 
   DECL_GFX_PREF(Live, "gfx.color_management.enablev4",         CMSEnableV4, bool, false);
   DECL_GFX_PREF(Live, "gfx.color_management.mode",             CMSMode, int32_t,-1);
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -7181,32 +7181,34 @@ nsDeviceContext* nsLayoutUtils::GetDevic
 }
 
 nsLayoutUtils::SurfaceFromElementResult
 nsLayoutUtils::SurfaceFromOffscreenCanvas(OffscreenCanvas* aOffscreenCanvas,
                                           uint32_t aSurfaceFlags,
                                           RefPtr<DrawTarget>& aTarget) {
   SurfaceFromElementResult result;
 
-  nsIntSize size = aOffscreenCanvas->GetWidthHeight();
+  IntSize size = aOffscreenCanvas->GetWidthHeight();
 
   result.mSourceSurface =
       aOffscreenCanvas->GetSurfaceSnapshot(&result.mAlphaType);
   if (!result.mSourceSurface) {
     // If the element doesn't have a context then we won't get a snapshot. The
     // canvas spec wants us to not error and just draw nothing, so return an
     // empty surface.
     result.mAlphaType = gfxAlphaType::Opaque;
     RefPtr<DrawTarget> ref =
         aTarget ? aTarget
                 : gfxPlatform::GetPlatform()->ScreenReferenceDrawTarget();
-    RefPtr<DrawTarget> dt = ref->CreateSimilarDrawTarget(
-        IntSize(size.width, size.height), SurfaceFormat::B8G8R8A8);
-    if (dt) {
-      result.mSourceSurface = dt->Snapshot();
+    if (ref->CanCreateSimilarDrawTarget(size, SurfaceFormat::B8G8R8A8)) {
+      RefPtr<DrawTarget> dt =
+          ref->CreateSimilarDrawTarget(size, SurfaceFormat::B8G8R8A8);
+      if (dt) {
+        result.mSourceSurface = dt->Snapshot();
+      }
     }
   } else if (aTarget) {
     RefPtr<SourceSurface> opt =
         aTarget->OptimizeSourceSurface(result.mSourceSurface);
     if (opt) {
       result.mSourceSurface = opt;
     }
   }
@@ -7359,20 +7361,22 @@ nsLayoutUtils::SurfaceFromElementResult 
   if (!result.mSourceSurface) {
     // If the element doesn't have a context then we won't get a snapshot. The
     // canvas spec wants us to not error and just draw nothing, so return an
     // empty surface.
     result.mAlphaType = gfxAlphaType::Opaque;
     RefPtr<DrawTarget> ref =
         aTarget ? aTarget
                 : gfxPlatform::GetPlatform()->ScreenReferenceDrawTarget();
-    RefPtr<DrawTarget> dt = ref->CreateSimilarDrawTarget(
-        IntSize(size.width, size.height), SurfaceFormat::B8G8R8A8);
-    if (dt) {
-      result.mSourceSurface = dt->Snapshot();
+    if (ref->CanCreateSimilarDrawTarget(size, SurfaceFormat::B8G8R8A8)) {
+      RefPtr<DrawTarget> dt =
+          ref->CreateSimilarDrawTarget(size, SurfaceFormat::B8G8R8A8);
+      if (dt) {
+        result.mSourceSurface = dt->Snapshot();
+      }
     }
   } else if (aTarget) {
     RefPtr<SourceSurface> opt =
         aTarget->OptimizeSourceSurface(result.mSourceSurface);
     if (opt) {
       result.mSourceSurface = opt;
     }
   }
diff --git a/layout/printing/DrawEventRecorder.h b/layout/printing/DrawEventRecorder.h
--- a/layout/printing/DrawEventRecorder.h
+++ b/layout/printing/DrawEventRecorder.h
@@ -100,17 +100,17 @@ class PRFileDescStream final : public mo
       return;
     }
 
     Flush();
     PRInt32 res = PR_Read(mFd, static_cast<void*>(aOut), aSize);
     mGood = res >= 0 && (static_cast<size_t>(res) == aSize);
   }
 
-  bool good() { return mGood; }
+  bool good() final { return mGood; }
 
  private:
   size_t AvailableBufferSpace() { return kBufferSize - mBufferPos; }
 
   void WriteToBuffer(const char* aData, size_t aSize) {
     MOZ_ASSERT(aSize <= AvailableBufferSpace());
     memcpy(mBuffer.get() + mBufferPos, aData, aSize);
     mBufferPos += aSize;
diff --git a/layout/printing/PrintTranslator.cpp b/layout/printing/PrintTranslator.cpp
--- a/layout/printing/PrintTranslator.cpp
+++ b/layout/printing/PrintTranslator.cpp
@@ -41,25 +41,28 @@ bool PrintTranslator::TranslateRecording
   ReadElement(aRecording, minorRevision);
   if (minorRevision > kMinorRevision) {
     return false;
   }
 
   int32_t eventType;
   ReadElement(aRecording, eventType);
   while (aRecording.good()) {
-    UniquePtr<RecordedEvent> recordedEvent(RecordedEvent::LoadEventFromStream(
-        aRecording, static_cast<RecordedEvent::EventType>(eventType)));
+    bool success = RecordedEvent::DoWithEventFromStream(
+        aRecording, static_cast<RecordedEvent::EventType>(eventType),
+        [&](RecordedEvent* recordedEvent) -> bool {
+          // Make sure that the whole event was read from the stream.
+          if (!aRecording.good()) {
+            return false;
+          }
 
-    // Make sure that the whole event was read from the stream successfully.
-    if (!aRecording.good() || !recordedEvent) {
-      return false;
-    }
+          return recordedEvent->PlayEvent(this);
+        });
 
-    if (!recordedEvent->PlayEvent(this)) {
+    if (!success) {
       return false;
     }
 
     ReadElement(aRecording, eventType);
   }
 
   return true;
 }
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -878,16 +878,17 @@ pref("gfx.font_rendering.directwrite.use
 // Disable antialiasing of Ahem, for use in tests
 pref("gfx.font_ahem_antialias_none", false);
 
 #ifdef XP_WIN
 // comma separated list of backends to use in order of preference
 // e.g., pref("gfx.canvas.azure.backends", "direct2d,skia,cairo");
 pref("gfx.canvas.azure.backends", "direct2d1.1,skia,cairo");
 pref("gfx.content.azure.backends", "direct2d1.1,skia,cairo");
+pref("gfx.canvas.remote", false);
 #else
 #ifdef XP_MACOSX
 pref("gfx.content.azure.backends", "skia");
 pref("gfx.canvas.azure.backends", "skia");
 #else
 pref("gfx.canvas.azure.backends", "skia");
 pref("gfx.content.azure.backends", "skia");
 #endif
diff --git a/xpcom/threads/nsThreadUtils.h b/xpcom/threads/nsThreadUtils.h
--- a/xpcom/threads/nsThreadUtils.h
+++ b/xpcom/threads/nsThreadUtils.h
@@ -364,16 +364,18 @@ bool SpinEventLoopUntil(Pred&& aPredicat
  * Returns true if we're in the compositor thread.
  *
  * We declare this here because the headers required to invoke
  * CompositorThreadHolder::IsInCompositorThread() also pull in a bunch of system
  * headers that #define various tokens in a way that can break the build.
  */
 extern bool NS_IsInCompositorThread();
 
+extern bool NS_IsInCanvasThread();
+
 extern bool NS_IsInVRThread();
 
 //-----------------------------------------------------------------------------
 // Helpers that work with nsCOMPtr:
 
 inline already_AddRefed<nsIThread> do_GetCurrentThread() {
   nsIThread* thread = nullptr;
   NS_GetCurrentThread(&thread);
